/*!
* \file   TFEL/Material/GeneralizedMaxwellBehaviourData.hxx
* \brief  this file implements the GeneralizedMaxwellBehaviourData class.
*         File generated by tfel version 3.2.1
* \author BenoÃ®t Bary
* \date   8 / 10 / 2014
 */

#ifndef LIB_TFELMATERIAL_GENERALIZEDMAXWELL_BEHAVIOUR_DATA_HXX
#define LIB_TFELMATERIAL_GENERALIZEDMAXWELL_BEHAVIOUR_DATA_HXX

#include<limits>
#include<string>
#include<sstream>
#include<iostream>
#include<stdexcept>
#include<algorithm>

#include"TFEL/Raise.hxx"
#include"TFEL/PhysicalConstants.hxx"
#include"TFEL/Config/TFELConfig.hxx"
#include"TFEL/Config/TFELTypes.hxx"
#include"TFEL/Metaprogramming/StaticAssert.hxx"
#include"TFEL/TypeTraits/IsFundamentalNumericType.hxx"
#include"TFEL/TypeTraits/IsReal.hxx"
#include"TFEL/Math/General/IEEE754.hxx"
#include"TFEL/Math/tvector.hxx"
#include"TFEL/Math/Vector/tvectorIO.hxx"
#include"TFEL/Math/stensor.hxx"
#include"TFEL/Math/Stensor/StensorConceptIO.hxx"
#include"TFEL/Math/tmatrix.hxx"
#include"TFEL/Math/Matrix/tmatrixIO.hxx"
#include"TFEL/Math/st2tost2.hxx"
#include"TFEL/Math/ST2toST2/ST2toST2ConceptIO.hxx"
#include"TFEL/Material/ModellingHypothesis.hxx"

#include"MFront/Aster/Aster.hxx"

namespace tfel{

namespace material{

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis,typename,bool>
class GeneralizedMaxwellBehaviourData;

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis,typename Type,bool use_qt>
class GeneralizedMaxwellIntegrationData;

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
std::ostream&
 operator <<(std::ostream&,const GeneralizedMaxwellBehaviourData<hypothesis,Type,false>&);

template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
class GeneralizedMaxwellBehaviourData<hypothesis,Type,false>
{

static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;
TFEL_STATIC_ASSERT(N==1||N==2||N==3);
TFEL_STATIC_ASSERT(tfel::typetraits::IsFundamentalNumericType<Type>::cond);
TFEL_STATIC_ASSERT(tfel::typetraits::IsReal<Type>::cond);

friend std::ostream& operator<< <>(std::ostream&,const GeneralizedMaxwellBehaviourData&);

/* integration data is declared friend to access   driving variables at the beginning of the time step */
friend class GeneralizedMaxwellIntegrationData<hypothesis,Type,false>;

static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;

using ushort =  unsigned short;
using Types = tfel::config::Types<N,Type,false>;
using real                = typename Types::real;
using time                = typename Types::time;
using length              = typename Types::length;
using frequency           = typename Types::frequency;
using stress              = typename Types::stress;
using strain              = typename Types::strain;
using strainrate          = typename Types::strainrate;
using stressrate          = typename Types::stressrate;
using temperature         = typename Types::temperature;
using thermalexpansion    = typename Types::thermalexpansion;
using massdensity         = typename Types::massdensity;
using TVector             = typename Types::TVector;
using Stensor             = typename Types::Stensor;
using Stensor4            = typename Types::Stensor4;
using FrequencyStensor    = typename Types::FrequencyStensor;
using ForceTVector        = typename Types::ForceTVector;
using StressStensor       = typename Types::StressStensor;
using StressRateStensor   = typename Types::StressRateStensor;
using DisplacementTVector = typename Types::DisplacementTVector;
using StrainStensor       = typename Types::StrainStensor;
using StrainRateStensor   = typename Types::StrainRateStensor;
using StiffnessTensor     = typename Types::StiffnessTensor;
using Tensor              = typename Types::Tensor;
using FrequencyTensor     = typename Types::FrequencyTensor;
using StressTensor        = typename Types::StressTensor;
using ThermalExpansionCoefficientTensor = typename Types::ThermalExpansionCoefficientTensor;
using DeformationGradientTensor         = typename Types::DeformationGradientTensor;
using DeformationGradientRateTensor     = typename Types::DeformationGradientRateTensor;
using TangentOperator   = StiffnessTensor;
using PhysicalConstants = tfel::PhysicalConstants<real>;

protected:

StrainStensor eto;

StressStensor sig;

#line 12 "GeneralizedMaxwell.mfront"
real k0;
#line 14 "GeneralizedMaxwell.mfront"
real mu0;
#line 17 "GeneralizedMaxwell.mfront"
tfel::math::tvector<3, real > ki;
#line 19 "GeneralizedMaxwell.mfront"
tfel::math::tvector<3, real > mui;
#line 21 "GeneralizedMaxwell.mfront"
tfel::math::tvector<3, real > taui;

#line 24 "GeneralizedMaxwell.mfront"
tfel::math::tvector<3, StressStensor > sej;
temperature T;

public:

/*!
* \brief Default constructor
*/
GeneralizedMaxwellBehaviourData()
{}

/*!
* \brief Copy constructor
*/
GeneralizedMaxwellBehaviourData(const GeneralizedMaxwellBehaviourData& src)
: eto(src.eto),
sig(src.sig)
,
k0(src.k0),
mu0(src.mu0),
ki(src.ki),
mui(src.mui),
taui(src.taui),
sej(src.sej),
T(src.T)
{}

/*
 * \brief constructor for the Aster interface
 * \param[in] ASTERT_: temperature
 * \param[in] ASTERmat: material properties
 * \param[in] ASTERint_vars: state variables
 * \param[in] ASTERext_vars: external std::ate variables
 */
GeneralizedMaxwellBehaviourData(const Type* const ASTERT_,const Type* const ASTERmat,
const Type* const ASTERint_vars
,const Type* const)
: k0(ASTERmat[0]),
mu0(ASTERmat[1]),
T(*ASTERT_)
{
ki[0] = ASTERmat[2];
ki[1] = ASTERmat[3];
ki[2] = ASTERmat[4];
mui[0] = ASTERmat[5];
mui[1] = ASTERmat[6];
mui[2] = ASTERmat[7];
taui[0] = ASTERmat[8];
taui[1] = ASTERmat[9];
taui[2] = ASTERmat[10];
sej[0].import(&ASTERint_vars[0]);
sej[1].import(&ASTERint_vars[StensorSize]);
sej[2].import(&ASTERint_vars[2*StensorSize]);
}

void setASTERBehaviourDataGradients(const Type* const ASTERstran)
{
this->eto.importVoigt(ASTERstran);
}

void setASTERBehaviourDataThermodynamicForces(const Type* const ASTERstress_)
{
this->sig.importTab(ASTERstress_);
}


/*
* \brief Assignement operator
*/
GeneralizedMaxwellBehaviourData&
operator=(const GeneralizedMaxwellBehaviourData& src){
this->eto = src.eto;
this->sig = src.sig;
this->k0 = src.k0;
this->mu0 = src.mu0;
this->ki = src.ki;
this->mui = src.mui;
this->taui = src.taui;
this->sej = src.sej;
this->T = src.T;
return *this;
}

void
ASTERexportStateData(Type * const ASTERstress_,Type * const ASTERstatev) const
{
using namespace tfel::math;
this->sig.exportTab(ASTERstress_);
exportToBaseTypeArray(this->sej[0],&ASTERstatev[0]);
exportToBaseTypeArray(this->sej[1],&ASTERstatev[StensorSize]);
exportToBaseTypeArray(this->sej[2],&ASTERstatev[2*StensorSize]);
} // end of ASTERexportStateData

}; // end of GeneralizedMaxwellBehaviourDataclass

template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
std::ostream&
operator <<(std::ostream& os,const GeneralizedMaxwellBehaviourData<hypothesis,Type,false>& b)
{
using namespace std;
os << "eto : " << b.eto << '\n';
os << "sig : " << b.sig << '\n';
os << "T : " << b.T << endl;
os << "k0 : " << b.k0 << '\n';
os << "mu0 : " << b.mu0 << '\n';
os << "ki : " << b.ki << '\n';
os << "mui : " << b.mui << '\n';
os << "taui : " << b.taui << '\n';
os << "sej : " << b.sej << '\n';
os << "T : " << b.T << '\n';
return os;
}

} // end of namespace material

} // end of namespace tfel

#endif /* LIB_TFELMATERIAL_GENERALIZEDMAXWELL_BEHAVIOUR_DATA_HXX */
