######################################################
# CRAIG-BAMPTON MODELISATION with coupling modes : Phase 2 / Run simulation
######################################################
POURSUITE(PAR_LOT='NON')

from Utilitai import partition
import numpy as np
import json
import math

######################################################
# Import parameters dictionnary
######################################################

with open('fort.2', 'r') as f:
    txt = f.read()
f.close()
parameters = json.loads(txt)

nSlp = parameters['nSlp']
USP_on = parameters['USP_on']
freq1 = parameters['frequencies'][0]
freq2 = parameters['frequencies'][-1]
nuPadMat1 = parameters['nuMat1']
nuPadMat2 = parameters['nuMat2']
coefSlpBotArea = parameters['balAreaCoef']
nuBal = parameters['nuBal']
hBal = parameters['hBal']
slpForce = parameters['slpForce']
nForce = parameters['forceNode']
nModesRai = int(parameters['nModesRai'])
nModesSlp = int(parameters['nModesSlp'])
fDirVert = parameters['fDirVert']
fDirLat = parameters['fDirLat']
computeAcoustic = parameters['computeAcoustic']
FRFtype = parameters['outputType']
selectedSubstFRF = parameters['selectedSubstFRF']
nodesFRF = parameters['nodesFRF']

ERail = parameters['ERail']
nuRail = parameters['nuRail']
tanDRail = parameters['tanDRail']
rhoRail = parameters['rhoRail']
E1Sleeper = parameters['E1Sleeper']
E2Sleeper = parameters['E2Sleeper']
E3Sleeper = parameters['E3Sleeper']
nuSleeper = parameters['nuSleeper']
tanDSleeper = parameters['tanDSleeper']
rhoSleeper = parameters['rhoSleeper']
sleeperHeight = parameters['slpHeight']
slpSpacing = parameters['slpSpacing']

clampStiffX = parameters['clampStiffX']*1000/2
clampStiffY = parameters['clampStiffY']*1000/2
clampStiffZ = parameters['clampStiffZ']*1000/2
clampDampX = parameters['clampDampX']/2
clampDampY = parameters['clampDampY']/2
clampDampZ = parameters['clampDampZ']/2
writeMED = parameters['writeMED']

nSlpAcoust1 = parameters['nSlpAcoust1']
nSlpAcoust2 = parameters['nSlpAcoust2']
cumulX_mini = parameters['cumulMassEffeUn']
cumulY_mini = cumulX_mini
cumulZ_mini = cumulX_mini

if USP_on == True:
    nuUSP = parameters['nuUSP']
    thkUSP = parameters['thkUSP']

if computeAcoustic:
    acMeshDim = parameters['acMeshDim']
    ac_setListX = {"rails" : (), "sleepers" : ("slpAcX",)} # X=track
    ac_setListY = {"rails" : ("railAcY",), "sleepers" : ("slpAcY",)} # Y=vertical
    ac_setListZ = {"rails" : ("railAcZ",), "sleepers" : ()} # Z=lateral

# sleeper scaling (not implemented in GUI)
try:
    scaling_slpX = parameters['scaling_slpX']
    scaling_slpY = parameters['scaling_slpY']
except:
    scaling_slpX = 1.0
    scaling_slpY = 1.0

<<<<<<< Updated upstream
# add the group of node to compute a static compression mode
# h = 392.945
# if USP_on:
#     h += thkUSP
# try:
#     mesh = DEFI_GROUP(reuse=mesh, MAILLAGE=mesh, DETR_GROUP_NO = _F(NOM='nAbvSlp'))
# except:
#     pass
# mesh = DEFI_GROUP(reuse=mesh, MAILLAGE=mesh, CREA_GROUP_NO=_F(NOM = 'nAbvSlp', OPTION='ENV_SPHERE', POINT=(0, h+2, 753.242), RAYON=2, PRECISION=0.1))
=======
# macroElements 2 & 2S (symmetric version) (not implemented in GUI)
# Phase 1: if different mat props but same mesh (no sleeper shift), and computeModeShapesPh1 False, no need to compute new macroelement mode shapes.
# True if either: a separate macroEl is requested for macroEl2, or a sleeper shift is set (!=0)
bool_macroEl2_Ph1 = ('macroEl2' in parameters.keys()) and ((("computeModeShapesPh1" in parameters['macroEl2'].keys()) and (parameters['macroEl2']['computeModeShapesPh1'] is True)) or (("slpShift" in parameters['macroEl2'].keys()) and (parameters['macroEl2']['slpShift'] !=0)))

# Phase 2: even if mode shapes not computed in Ph1 for macroEl2, macroEl 2/2S are computed based on nominal mode shapes
bool_macroEl2_Ph2 = 'macroEl2' in parameters.keys() and 'macroElSequence' in parameters.keys() and (2 in parameters['macroElSequence'] or 3 in parameters['macroElSequence'])

# With a sleeper shift, the macroelement is not symmetric anymore ; so: need to create another macroelement with -slpShift to make the left side of the track
bool_macroEl2_slpShift = bool_macroEl2_Ph1 and bool_macroEl2_Ph2 and "slpShift" in parameters['macroEl2'].keys() and parameters['macroEl2']['slpShift'] !=0

######################################################
# Get list of frequencies from freq file
######################################################
with open('fort.40') as freqFile:
    freqlines = freqFile.read().splitlines()
freqFile.close()

allFreqsJob = []
for freqline in freqlines:
    try:
        frequency=float(freqline.split(' ')[0])
    except:
        continue
    allFreqsJob.append(frequency)

meanFreqJob = (allFreqsJob[0] + allFreqsJob[-1])/2
>>>>>>> Stashed changes

######################################################
# Define functions
######################################################
def GetEigenModesList(p_path, p_cumulX_mini, p_cumulY_mini, p_cumulZ_mini):
    with open(p_path, 'r') as f:
        lines = f.read().splitlines()
    f.close()

    modes = []
    for line in lines:
        splittedLine = line.split(' ')
        splittedLine = [x for x in splittedLine if x != '']
        if not splittedLine:
            continue

        try:
            modeNbr = int(splittedLine[0])
            freq = float(splittedLine[1].replace('D', 'e'))
            MASS_EFFE_UN_DX = float(splittedLine[2].replace('D', 'e'))
            MASS_EFFE_UN_DY = float(splittedLine[3].replace('D', 'e'))
            MASS_EFFE_UN_DZ = float(splittedLine[4].replace('D', 'e'))
        except:
            continue

        mode = {'no' : modeNbr, 'freq' : freq, 'massX' : MASS_EFFE_UN_DX, 'massY' : MASS_EFFE_UN_DY, 'massZ' : MASS_EFFE_UN_DZ, 'massYZ' : MASS_EFFE_UN_DY + MASS_EFFE_UN_DZ}
        modes.append(mode)

    sortedModesX = sorted(modes, key=lambda d: d['massX'], reverse=True)
    sortedModesY = sorted(modes, key=lambda d: d['massY'], reverse=True)
    sortedModesZ = sorted(modes, key=lambda d: d['massZ'], reverse=True)

    listModesX = []
    cumulX = 0
    for mode in sortedModesX:
        cumulX += mode['massX']
        listModesX.append(mode['no'])
        if cumulX > p_cumulX_mini:
            break

    if cumulX < p_cumulX_mini:
        print('Warning: the effective mass cumulation requested in X was ' + str(p_cumulX_mini) + '. The actual value obtained is ' + str(cumulX))

    listModesY = []
    cumulY = 0
    for mode in sortedModesY:
        cumulY += mode['massY']
        listModesY.append(mode['no'])
        if cumulY > p_cumulY_mini:
            break

    if cumulY < p_cumulY_mini:
        print('Warning: the effective mass cumulation requested in Y was ' + str(p_cumulY_mini) + '. The actual value obtained is ' + str(cumulY))

    listModesZ = []
    cumulZ = 0
    for mode in sortedModesZ:
        cumulZ += mode['massZ']
        listModesZ.append(mode['no'])
        if cumulZ > p_cumulZ_mini:
            break

    if cumulZ < p_cumulZ_mini:
        print('Warning: the effective mass cumulation requested in Z was ' + str(p_cumulZ_mini) + '. The actual value obtained is ' + str(cumulZ))

    listModes = sorted(list(set(listModesX + listModesY + listModesZ)))
    if listModes == []:
        listModes.append(1)

    print('Eigenmodes X (' + str(len(listModesX)) +  ') : ' + str(listModesX))
    print('Eigenmodes Y (' + str(len(listModesY)) +  ') : ' + str(listModesY))
    print('Eigenmodes Z (' + str(len(listModesZ)) +  ') : ' + str(listModesZ))
    print('Selected eigenmodes (' + str(len(listModes)) +  ') : ' + str(listModes))

    return listModes

def GetAlphaBeta(p_freqList, p_dampingList):
# Computes optimized Rayleigh's coefs alpha & beta ( eta=1/2*(alpha*w+beta/w) )
# freqList in Hz ; damping list = corresponding hysteretic damping
    
    freqList = np.array(p_freqList)
    dampingList = np.array(p_dampingList)

    if len(freqList) == 1: # only 1 freq: set beta to 0 and alpha s.t. damping is exact
        return [dampingList[0]/(pi*freqList[0]), 0] 
    elif len(freqList) == 2: # only 2 freqs: return alpha, beta s.t. damping is exact at both freqs
        f0 = freqList[0]
        f1 = freqList[1]
        eta0 = dampingList[0]
        eta1 = dampingList[1]
        alpha = eta0/(pi*f0)*(1 - f1/eta0 * (eta0*f1-eta1*f0)/(f1**2-f0**2))
        beta = 4*pi*f0*f1 * (eta0*f1-eta1*f0)/(f1**2-f0**2)
        return [alpha, beta]

    # more than 2 freqs: use least squares method to optimize damping
    A = np.trapz(dampingList*2*pi*freqList, 2*pi*freqList)
    B = np.trapz(dampingList/(2*pi*freqList), 2*pi*freqList)
    vect = np.array([[A], [B]])
    w1 = 2*pi*freqList[0]
    w2 = 2*pi*freqList[-1]
    M = 12/((w2**3-w1**3)*(1/w1-1/w2) - 3*(w2-w1)**2) * np.array([[1/2*(1/w1-1/w2), -1/2*(w2-w1)], [-1/2*(w2-w1), 1/6*(w2**3-w1**3)]])
    alphaBeta = np.dot(M, vect)
    alpha = float(alphaBeta[0])
    beta = float(alphaBeta[1])
    return [alpha, beta]

def DictToTuple(myDict):
    temp = []
    for val in myDict.values():
        if val != ():
            for id, grp in enumerate(val):
                temp.append(grp)
    
    myTuple = tuple(temp)
    return myTuple

def computeDistance(femodel, femesh, coords, ac_grps, iElem, side):
    # distance function [m]
    
    allGrps_dirI = DictToTuple(ac_grps)
            
    if side == 'R':
        dist = FORMULE(NOM_PARA=('X', 'Y', 'Z'),
                       VALE='sqrt(pow(X-XP+iElem*slpSpacing,2)+pow(Y-YP,2)+pow(Z-ZP,2))/1000',
                       XP=coords[0], YP=coords[1], ZP=coords[2], iElem=iElem, slpSpacing=slpSpacing)
    elif side == 'L':
        dist = FORMULE(NOM_PARA=('X', 'Y', 'Z'),
                       VALE='sqrt(pow(-X-XP+iElem*slpSpacing,2)+pow(Y-YP,2)+pow(-Z-ZP,2))/1000', # X-XP+XT (XT: translation vector)
                       XP=coords[0], YP=coords[1], ZP=coords[2], iElem=iElem, slpSpacing=slpSpacing)

    chFDist = CREA_CHAMP(AFFE=_F(GROUP_MA=allGrps_dirI,
                             NOM_CMP=('X1', ),
                             VALE_F=(dist, )),
                     MODELE=femodel,
                     OPERATION='AFFE',
                     TYPE_CHAM='NOEU_NEUT_F')

    chgeom = CREA_CHAMP(MAILLAGE=femesh,
                    NOM_CHAM='GEOMETRIE',
                    OPERATION='EXTR',
                    TYPE_CHAM='NOEU_GEOM_R')

    chDist = CREA_CHAMP(CHAM_F=chFDist,
                    CHAM_PARA=(chgeom, ),
                    OPERATION='EVAL',
                    TYPE_CHAM='NOEU_NEUT_R')

    DETRUIRE(CONCEPT=_F(NOM=(dist, chFDist, chgeom, )))

    return chDist

def computePressure(p_femodel, p_chFprss, p_acGrps, p_velocR, p_velocI, p_side, p_chDist, p_CHk, p_CHcoef, p_CH1, p_CHm1):

    p_rails_R = 0.0
    p_rails_I = 0.0
    p_sleepers_R = 0.0
    p_sleepers_I = 0.0

    if p_side == 'R':
        pressAcR = CREA_CHAMP(CHAM_F=p_chFprss,
                              CHAM_PARA=(p_chDist, p_CHk, p_CHcoef, p_velocR, p_CH1),
                              OPERATION='EVAL',
                              TYPE_CHAM='NOEU_NEUT_R')
                              
        pressAcI = CREA_CHAMP(CHAM_F=p_chFprss,
                              CHAM_PARA=(p_chDist, p_CHk, p_CHcoef, p_velocI, p_CH1),
                              OPERATION='EVAL',
                              TYPE_CHAM='NOEU_NEUT_R')
    elif p_side == 'L':
        pressAcR = CREA_CHAMP(CHAM_F=p_chFprss,
                              CHAM_PARA=(p_chDist, p_CHk, p_CHcoef, p_velocR, p_CHm1),
                              OPERATION='EVAL',
                              TYPE_CHAM='NOEU_NEUT_R')
                              
        pressAcI = CREA_CHAMP(CHAM_F=p_chFprss,
                              CHAM_PARA=(p_chDist, p_CHk, p_CHcoef, p_velocI, p_CHm1),
                              OPERATION='EVAL',
                              TYPE_CHAM='NOEU_NEUT_R')

    if p_acGrps['rails'] != ():
        intR_R = POST_ELEM(CHAM_GD=pressAcR,
                           INTEGRALE=_F(GROUP_MA=p_acGrps['rails'],
                                        NOM_CMP=('X5', 'X6'),
                                        TYPE_MAILLE='2D'),
                           MODELE=p_femodel)
        intR_I = POST_ELEM(CHAM_GD=pressAcI,
                           INTEGRALE=_F(GROUP_MA=p_acGrps['rails'],
                                        NOM_CMP=('X5', 'X6'),
                                        TYPE_MAILLE='2D'),
                           MODELE=p_femodel)
                           
        p_rails_R = (intR_R['INTE_X5', 1] - intR_I['INTE_X6', 1])/1e6
        p_rails_I = (intR_R['INTE_X6', 1] + intR_I['INTE_X5', 1])/1e6
        DETRUIRE(CONCEPT=_F(NOM=(intR_R, intR_I, )))    
        
    if p_acGrps['sleepers'] != ():
        intS_R = POST_ELEM(CHAM_GD=pressAcR,
                           INTEGRALE=_F(GROUP_MA=p_acGrps['sleepers'],
                                        NOM_CMP=('X5', 'X6'),
                                        TYPE_MAILLE='2D'),
                           MODELE=p_femodel)
        intS_I = POST_ELEM(CHAM_GD=pressAcI,
                           INTEGRALE=_F(GROUP_MA=p_acGrps['sleepers'],
                                        NOM_CMP=('X5', 'X6'),
                                        TYPE_MAILLE='2D'),
                           MODELE=p_femodel)
                           
        p_sleepers_R = (intS_R['INTE_X5', 1] - intS_I['INTE_X6', 1])/1e6
        p_sleepers_I = (intS_R['INTE_X6', 1] + intS_I['INTE_X5', 1])/1e6
        DETRUIRE(CONCEPT=_F(NOM=(intS_R, intS_I, )))

    DETRUIRE(CONCEPT=_F(NOM=(pressAcR, pressAcI, )))
    return [p_rails_R, p_rails_I, p_sleepers_R, p_sleepers_I]


######################################################
# MESHES AND MODEL
######################################################
halfDistRails = 757.54
padVerticalOffset = sleeperHeight*scaling_slpY
padThickness = 7.0
railTiltXrad = -math.atan(1/40.0)
railTiltX = railTiltXrad*180/math.pi
railVerticalOffset = padVerticalOffset + padThickness*math.cos(railTiltXrad)

# Sleeper
meshSlp = LIRE_MAILLAGE(FORMAT="MED",UNITE=21);

dplX_slp = FORMULE(NOM_PARA=('X', 'Y', 'Z'), VALE='X*(scaling-1)', scaling=scaling_slpX,)
               
dplY_slp = FORMULE(NOM_PARA=('X', 'Y', 'Z'), VALE='Y*(scaling-1)', scaling=scaling_slpY)
               
dplZ_slp = FORMULE(NOM_PARA=('X', 'Y', 'Z'), VALE='Z*0',)

CHdplF = CREA_CHAMP(AFFE=_F(TOUT='OUI',
                             NOM_CMP=('X1', 'X2', 'X3'),
                             VALE_F=(dplX_slp, dplY_slp, dplZ_slp)),
                     OPERATION='AFFE',
                     MAILLAGE=meshSlp,
                     TYPE_CHAM='NOEU_NEUT_F')

CHcoord = CREA_CHAMP(MAILLAGE=meshSlp,
                    NOM_CHAM='GEOMETRIE',
                    OPERATION='EXTR',
                    TYPE_CHAM='NOEU_GEOM_R')

temp = CREA_CHAMP(CHAM_F=CHdplF,
                    CHAM_PARA=(CHcoord, ),
                    OPERATION='EVAL',
                    TYPE_CHAM='NOEU_NEUT_R')

CHdpl=CREA_CHAMP(OPERATION='ASSE', TYPE_CHAM='NOEU_DEPL_R', MAILLAGE=meshSlp,
                  ASSE=_F(TOUT = 'OUI', CHAM_GD = temp,
                          NOM_CMP = ('X1', 'X2', 'X3',),
                          NOM_CMP_RESU = ('DX','DY','DZ',)))


meshSlp = MODI_MAILLAGE(reuse=meshSlp, MAILLAGE=meshSlp, 
                     DEFORME=_F(OPTION='TRAN', DEPL=CHdpl))

DETRUIRE(CONCEPT=_F(NOM=(CHdplF, CHcoord, temp, CHdpl)))

# Rail
meshRaiR = LIRE_MAILLAGE(FORMAT="MED",UNITE=25);

try:
    meshRaiR = DEFI_GROUP(reuse=meshRaiR, MAILLAGE=meshRaiR, 
                            DETR_GROUP_NO = _F(NOM='rntp'))
except:
    pass

meshRaiR = DEFI_GROUP(reuse=meshRaiR, MAILLAGE=meshRaiR, 
                        CREA_GROUP_NO = _F(NOM='rntp', OPTION='PLAN', POINT=(0,0,0), VECT_NORMALE=(0,-1,0), PRECISION=1e-3))

try:
    meshRaiR = DEFI_GROUP(reuse=meshRaiR, MAILLAGE=meshRaiR, 
                            DETR_GROUP_MA = _F(NOM='retp'))
except:
    pass

meshRaiR = DEFI_GROUP(reuse=meshRaiR, MAILLAGE=meshRaiR, 
                        CREA_GROUP_MA = _F(TYPE_MAILLE='3D', NOM='retp', OPTION='APPUI', TYPE_APPUI='AU_MOINS_UN', GROUP_NO='rntp'))

meshRaiR = DEFI_GROUP(reuse=meshRaiR, MAILLAGE=meshRaiR, 
                        DETR_GROUP_NO = _F(NOM='rntp'))

scaling_rai = slpSpacing/600.0

dplX_rai = FORMULE(NOM_PARA=('X', 'Y', 'Z'), VALE='X*(scaling-1)', scaling=scaling_rai,)
               
dplY_rai = FORMULE(NOM_PARA=('X', 'Y', 'Z'), VALE='Y*0',)
               
dplZ_rai = FORMULE(NOM_PARA=('X', 'Y', 'Z'), VALE='Z*0',)

CHdplF = CREA_CHAMP(AFFE=_F(TOUT='OUI',
                             NOM_CMP=('X1', 'X2', 'X3'),
                             VALE_F=(dplX_rai, dplY_rai, dplZ_rai)),
                     OPERATION='AFFE',
                     MAILLAGE=meshRaiR,
                     TYPE_CHAM='NOEU_NEUT_F')

CHcoord = CREA_CHAMP(MAILLAGE=meshRaiR,
                    NOM_CHAM='GEOMETRIE',
                    OPERATION='EXTR',
                    TYPE_CHAM='NOEU_GEOM_R')

temp = CREA_CHAMP(CHAM_F=CHdplF,
                    CHAM_PARA=(CHcoord, ),
                    OPERATION='EVAL',
                    TYPE_CHAM='NOEU_NEUT_R')

CHdpl=CREA_CHAMP(OPERATION='ASSE', TYPE_CHAM='NOEU_DEPL_R', MAILLAGE=meshRaiR,
                  ASSE=_F(TOUT = 'OUI', CHAM_GD = temp,
                          NOM_CMP = ('X1', 'X2', 'X3',),
                          NOM_CMP_RESU = ('DX','DY','DZ',)))

meshRaiR = MODI_MAILLAGE(reuse=meshRaiR, MAILLAGE=meshRaiR, 
                     DEFORME=_F(OPTION='TRAN', DEPL=CHdpl))

meshRaiR = MODI_MAILLAGE(reuse=meshRaiR,
                       MAILLAGE=meshRaiR,
                       ROTATION=_F(
                         ANGLE=railTiltX, 
                         POIN_1=(0.0, 0.0, 0.0), 
                         POIN_2=(1000.0, 0.0, 0.0)))

meshRaiR = MODI_MAILLAGE(reuse=meshRaiR,
                       MAILLAGE=meshRaiR,
                       TRANSLATION=(0.0, railVerticalOffset, halfDistRails),)

DETRUIRE(CONCEPT=_F(NOM=(CHdplF, CHcoord, temp, CHdpl)))

# Pad
meshPadR = LIRE_MAILLAGE(FORMAT="MED",UNITE=23);

CHdplF = CREA_CHAMP(AFFE=_F(TOUT='OUI',
                             NOM_CMP=('X1', 'X2', 'X3'),
                             VALE_F=(dplX_slp, dplY_rai, dplZ_rai)),
                     OPERATION='AFFE',
                     MAILLAGE=meshPadR,
                     TYPE_CHAM='NOEU_NEUT_F')

CHcoord = CREA_CHAMP(MAILLAGE=meshPadR,
                    NOM_CHAM='GEOMETRIE',
                    OPERATION='EXTR',
                    TYPE_CHAM='NOEU_GEOM_R')

temp = CREA_CHAMP(CHAM_F=CHdplF,
                    CHAM_PARA=(CHcoord, ),
                    OPERATION='EVAL',
                    TYPE_CHAM='NOEU_NEUT_R')

CHdpl=CREA_CHAMP(OPERATION='ASSE', TYPE_CHAM='NOEU_DEPL_R', MAILLAGE=meshPadR,
                  ASSE=_F(TOUT = 'OUI', CHAM_GD = temp,
                          NOM_CMP = ('X1', 'X2', 'X3',),
                          NOM_CMP_RESU = ('DX','DY','DZ',)))


meshPadR = MODI_MAILLAGE(reuse=meshPadR, MAILLAGE=meshPadR, 
                     DEFORME=_F(OPTION='TRAN', DEPL=CHdpl))

meshPadR = MODI_MAILLAGE(reuse=meshPadR,
                       MAILLAGE=meshPadR,
                       ROTATION=_F(
                         ANGLE=railTiltX, 
                         POIN_1=(0.0, 0.0, 0.0), 
                         POIN_2=(1000.0, 0.0, 0.0)))

meshPadR = MODI_MAILLAGE(reuse=meshPadR,
                       MAILLAGE=meshPadR,
                       TRANSLATION=(0.0, padVerticalOffset, halfDistRails),)



# USP
if USP_on:
    DETRUIRE(CONCEPT=_F(NOM=(CHdplF, CHcoord, temp, CHdpl)))
    
    meshUSP = LIRE_MAILLAGE(FORMAT="MED",UNITE=26);
    
    meshUSP = DEFI_GROUP(reuse=meshUSP, MAILLAGE=meshUSP, 
                         CREA_GROUP_MA = _F(TYPE_MAILLE='2D', NOM='USPbot', OPTION='FACE_NORMALE', VECT_NORMALE=(0,-1,0)))

    meshUSP = DEFI_GROUP(reuse=meshUSP, MAILLAGE=meshUSP, 
                         CREA_GROUP_NO = _F(NOM='USPbot', GROUP_MA='USPbot'))
                         
    meshUSP = DEFI_GROUP(reuse=meshUSP, MAILLAGE=meshUSP, 
                         CREA_GROUP_NO = _F(NOM='USPtop', OPTION='PLAN', POINT=(0,thkUSP,0), VECT_NORMALE=(0,1,0), PRECISION=1e-3))
    ###                     
    meshUSP = DEFI_GROUP(reuse=meshUSP, MAILLAGE=meshUSP, 
                         CREA_GROUP_NO = _F(NOM='tmp', OPTION='PLAN', POINT=(0,0,0), VECT_NORMALE=(0,0,1), PRECISION=1e-3))

    meshUSP = DEFI_GROUP(reuse=meshUSP, MAILLAGE=meshUSP, 
                         CREA_GROUP_NO = _F(NOM='USPsym', DIFFE=('tmp', 'USPtop')))

    meshUSP = DEFI_GROUP(reuse=meshUSP, MAILLAGE=meshUSP, 
                         DETR_GROUP_NO = _F(NOM='tmp'))
    

    CHdplF = CREA_CHAMP(AFFE=_F(TOUT='OUI',
                                NOM_CMP=('X1', 'X2', 'X3'),
                                VALE_F=(dplX_slp, dplY_rai, dplZ_rai)),
                        OPERATION='AFFE',
                        MAILLAGE=meshUSP,
                        TYPE_CHAM='NOEU_NEUT_F')

    CHcoord = CREA_CHAMP(MAILLAGE=meshUSP,
                        NOM_CHAM='GEOMETRIE',
                        OPERATION='EXTR',
                        TYPE_CHAM='NOEU_GEOM_R')

    temp = CREA_CHAMP(CHAM_F=CHdplF,
                        CHAM_PARA=(CHcoord, ),
                        OPERATION='EVAL',
                        TYPE_CHAM='NOEU_NEUT_R')

    CHdpl=CREA_CHAMP(OPERATION='ASSE', TYPE_CHAM='NOEU_DEPL_R', MAILLAGE=meshUSP,
                    ASSE=_F(TOUT = 'OUI', CHAM_GD = temp,
                            NOM_CMP = ('X1', 'X2', 'X3',),
                            NOM_CMP_RESU = ('DX','DY','DZ',)))


    meshUSP = MODI_MAILLAGE(reuse=meshUSP, MAILLAGE=meshUSP, 
                        DEFORME=_F(OPTION='TRAN', DEPL=CHdpl))

    # Delete all groups of meshSlp that exist in meshUSP
    pyUSP = partition.MAIL_PY()
    pyUSP.FromAster('meshUSP')
    pySlp = partition.MAIL_PY()
    pySlp.FromAster('meshSlp')
    nodeGrpsUSP = meshUSP.LIST_GROUP_NO()
    nodeGrpsSlp = meshSlp.LIST_GROUP_NO()
    maGrpsUSP = meshUSP.LIST_GROUP_MA()
    maGrpsSlp = meshSlp.LIST_GROUP_MA()

    delGpNo = [gp[0] for gp in nodeGrpsUSP if gp in nodeGrpsSlp]
    delGpMa = [gp[0] for gp in maGrpsUSP if gp in maGrpsSlp]

    if delGpNo != []:
        meshSlp = DEFI_GROUP(reuse=meshSlp, MAILLAGE=meshSlp, DETR_GROUP_NO=_F(NOM=delGpNo))

    if delGpMa != []:
        meshSlp = DEFI_GROUP(reuse=meshSlp, MAILLAGE=meshSlp, DETR_GROUP_MA=_F(NOM=delGpMa))

    # Translate components above USPs of USP's thickness
    meshSlp = MODI_MAILLAGE(reuse=meshSlp, MAILLAGE=meshSlp, TRANSLATION=(0, thkUSP, 0));
    meshPadR = MODI_MAILLAGE(reuse=meshPadR, MAILLAGE=meshPadR, TRANSLATION=(0, thkUSP, 0));
    meshRaiR = MODI_MAILLAGE(reuse=meshRaiR, MAILLAGE=meshRaiR, TRANSLATION=(0, thkUSP, 0));

# Assemble meshes
if USP_on:
    tmp = ASSE_MAILLAGE(MAILLAGE_1=meshUSP, MAILLAGE_2=meshSlp, OPERATION='SUPERPOSE')
    tmp2 = ASSE_MAILLAGE(MAILLAGE_1=tmp, MAILLAGE_2=meshPadR, OPERATION='SUPERPOSE')  
    DETRUIRE(CONCEPT=_F(NOM=(tmp)))  
    discreteBalNodes = 'USPbot'
else:
    tmp2 = ASSE_MAILLAGE(MAILLAGE_1=meshSlp, MAILLAGE_2=meshPadR, OPERATION='SUPERPOSE')
    discreteBalNodes = 'sntb'

mesh_1 = ASSE_MAILLAGE(MAILLAGE_1=tmp2, MAILLAGE_2=meshRaiR, OPERATION='SUPERPOSE') # macroelement 1 (nominal)

# Duplicate and translate (USP-)sleeper-pad mesh if other macroelements need to be defined with a sleeper shift
if bool_macroEl2_Ph2:
    slpShift = parameters['macroEl2'].get('slpShift') if parameters['macroEl2'].get('slpShift') is not None else 0
    tmp2_2 = COPIER(CONCEPT=tmp2 )
    tmp2_2 = MODI_MAILLAGE(reuse=tmp2_2, MAILLAGE=tmp2_2, TRANSLATION=(slpShift, 0, 0),)
    mesh_2 = ASSE_MAILLAGE(MAILLAGE_1=tmp2_2, MAILLAGE_2=meshRaiR, OPERATION='SUPERPOSE')
    DETRUIRE(CONCEPT=_F(NOM=(tmp2_2)))

DETRUIRE(CONCEPT=_F(NOM=(tmp2)))

# Add clamps ; use function bc 4 clamps per macroelement mesh
def ClampMesh(p_cps, p_clampIni, p_pyMesh, p_clampID, p_clampNo):
    clampDirIni = np.array([1,0,0])

    p_cps[p_clampNo] = COPIER(CONCEPT=p_clampIni ) # DETRUIRE() + recreate clamp object doesnt work within function ... so we create a new one every time

    p_cps[p_clampNo] = DEFI_GROUP(reuse=p_cps[p_clampNo], MAILLAGE=p_cps[p_clampNo], 
                                  CREA_GROUP_NO=(_F(NOM='clmp_' + p_clampID + '0', UNION=('n0')), _F(NOM='clmp_' + p_clampID + '1', UNION=('n1'))),
                                  CREA_GROUP_MA=_F(NOM='clmp_' + p_clampID, UNION=('clamp')))

    p_cps[p_clampNo] = DEFI_GROUP(reuse=p_cps[p_clampNo], MAILLAGE=p_cps[p_clampNo], 
                                  DETR_GROUP_NO=_F(NOM=('n0', 'n1')), 
                                  DETR_GROUP_MA=_F(NOM=('clamp')))

    nodeSlp = p_pyMesh.gno.get('sntr' + p_clampID)
    sntr = np.array(p_pyMesh.cn[nodeSlp[0]])
    leftRight = 'l' if p_clampID[0] == 'i' else 'r'
    nodeRai = p_pyMesh.gno.get('rnts' + leftRight + p_clampID[-1])
    rnts = np.array(p_pyMesh.cn[nodeRai[0]])

    clampVect = rnts - sntr
    clampLength = np.linalg.norm(clampVect)
    clampDir_u = clampVect/np.linalg.norm(clampLength)
    rotDir = np.cross(clampDirIni, clampDir_u)
    rotAngle = np.arccos(np.clip(np.dot(clampDirIni, clampDir_u), -1.0, 1.0))

    p_cps[p_clampNo] = MODI_MAILLAGE(reuse=p_cps[p_clampNo], MAILLAGE=p_cps[p_clampNo], ECHELLE=clampLength)

    p_cps[p_clampNo] = MODI_MAILLAGE(reuse=p_cps[p_clampNo], MAILLAGE=p_cps[p_clampNo], 
                          TRANSLATION=sntr,
                          ROTATION=_F(ANGLE=rotAngle*180/math.pi, POIN_1=sntr, DIR=rotDir),)
    
    return p_cps[p_clampNo]


clampIni = LIRE_MAILLAGE(FORMAT="MED",UNITE=22)
allClamps = [None]*4*(1 + int(bool_macroEl2_Ph2))

# Main mesh (nominal)
pyMesh1 = partition.MAIL_PY()
pyMesh1.FromAster('mesh_1')

clampia1 = ClampMesh(allClamps, clampIni, pyMesh1, 'ia', 0)
clampib1 = ClampMesh(allClamps, clampIni, pyMesh1, 'ib', 1)
clampea1 = ClampMesh(allClamps, clampIni, pyMesh1, 'ea', 2)
clampeb1 = ClampMesh(allClamps, clampIni, pyMesh1, 'eb', 3)

tmp3 = ASSE_MAILLAGE(MAILLAGE_1=mesh_1, MAILLAGE_2=clampia1, OPERATION='SUPERPOSE')
tmp4 = ASSE_MAILLAGE(MAILLAGE_1=tmp3, MAILLAGE_2=clampib1, OPERATION='SUPERPOSE')
tmp5 = ASSE_MAILLAGE(MAILLAGE_1=tmp4, MAILLAGE_2=clampea1, OPERATION='SUPERPOSE')
mesh0 = ASSE_MAILLAGE(MAILLAGE_1=tmp5, MAILLAGE_2=clampeb1, OPERATION='SUPERPOSE')
mesh0 = DEFI_GROUP(reuse=mesh0, MAILLAGE=mesh0, CREA_GROUP_MA=_F(NOM = 'TOUT', TOUT = 'OUI'))

mesh = CREA_MAILLAGE(CREA_POI1=_F(GROUP_NO=discreteBalNodes, 
                                  NOM_GROUP_MA=discreteBalNodes + '0D'), 
                     MAILLAGE=mesh0) 

DETRUIRE(CONCEPT=_F(NOM=(tmp3, tmp4, tmp5, mesh_1, mesh0)))

# Mesh macroelement 2
if bool_macroEl2_Ph2:
    pyMesh2 = partition.MAIL_PY()
    pyMesh2.FromAster('mesh_2')

    clampia2 = ClampMesh(allClamps, clampIni, pyMesh2, 'ia', 4)
    clampib2 = ClampMesh(allClamps, clampIni, pyMesh2, 'ib', 5)
    clampea2 = ClampMesh(allClamps, clampIni, pyMesh2, 'ea', 6)
    clampeb2 = ClampMesh(allClamps, clampIni, pyMesh2, 'eb', 7)

    tmp3 = ASSE_MAILLAGE(MAILLAGE_1=mesh_2, MAILLAGE_2=clampia2, OPERATION='SUPERPOSE')
    tmp4 = ASSE_MAILLAGE(MAILLAGE_1=tmp3, MAILLAGE_2=clampib2, OPERATION='SUPERPOSE')
    tmp5 = ASSE_MAILLAGE(MAILLAGE_1=tmp4, MAILLAGE_2=clampea2, OPERATION='SUPERPOSE')
    mesh0 = ASSE_MAILLAGE(MAILLAGE_1=tmp5, MAILLAGE_2=clampeb2, OPERATION='SUPERPOSE')
    mesh0 = DEFI_GROUP(reuse=mesh0, MAILLAGE=mesh0, CREA_GROUP_MA=_F(NOM = 'TOUT', TOUT = 'OUI'))

    mesh2 = CREA_MAILLAGE(CREA_POI1=_F(GROUP_NO=discreteBalNodes, 
                                    NOM_GROUP_MA=discreteBalNodes + '0D'), 
                        MAILLAGE=mesh0) 

    DETRUIRE(CONCEPT=_F(NOM=(tmp3, tmp4, tmp5, mesh_2, mesh0)))

# Make symmetrical mesh versions of macroelements that are not symmetrical
if bool_macroEl2_slpShift:
    mesh2S = COPIER(CONCEPT=mesh2)
    mesh2S = MODI_MAILLAGE(reuse=mesh2S, MAILLAGE=mesh2S, SYMETRIE=_F(POINT=(0,0,0), AXE_1=(0,1,0), AXE_2=(0,0,1)))

# print macro element mesh 1 (nominal) to med
try:
    IMPR_RESU(UNITE=27, RESU=_F(MAILLAGE=mesh))
except:
    pass

# Model for each macro-element
model = AFFE_MODELE(MAILLAGE=mesh,
                    AFFE=(_F(TOUT='OUI',
                            PHENOMENE='MECANIQUE',
                            MODELISATION='3D',),
                          _F(GROUP_MA=(discreteBalNodes + '0D', 'clmp_ia', 'clmp_ib', 'clmp_ea', 'clmp_eb'),
                             PHENOMENE='MECANIQUE',
                             MODELISATION='DIS_T',),))

if bool_macroEl2_Ph2:
    model2 = AFFE_MODELE(MAILLAGE=mesh2,
                        AFFE=(_F(TOUT='OUI',
                                PHENOMENE='MECANIQUE',
                                MODELISATION='3D',),
                            _F(GROUP_MA=(discreteBalNodes + '0D', 'clmp_ia', 'clmp_ib', 'clmp_ea', 'clmp_eb'),
                                PHENOMENE='MECANIQUE',
                                MODELISATION='DIS_T',),))
    
if bool_macroEl2_slpShift:
    model2S = AFFE_MODELE(MAILLAGE=mesh2S,
                        AFFE=(_F(TOUT='OUI',
                                PHENOMENE='MECANIQUE',
                                MODELISATION='3D',),
                            _F(GROUP_MA=(discreteBalNodes + '0D', 'clmp_ia', 'clmp_ib', 'clmp_ea', 'clmp_eb'),
                                PHENOMENE='MECANIQUE',
                                MODELISATION='DIS_T',),))

# Compute area of a half-sleeper bottom face
CH_id = CREA_CHAMP(OPERATION = 'AFFE',
                      TYPE_CHAM ='NOEU_NEUT_R',
                      MAILLAGE = mesh ,
                      AFFE = _F(GROUP_MA='sftb', NOM_CMP=('X1'), VALE=1.0,))

intCH_id = POST_ELEM(CHAM_GD=CH_id,
                     INTEGRALE=_F(GROUP_MA='sftb',
                                  NOM_CMP=('X1'),
                                  TYPE_MAILLE='2D'),
                     MODELE=model)
                     
A_slpBot = intCH_id['INTE_X1',1]

# Get number of nodes in discreteBalNodes
pyMesh = partition.MAIL_PY()
pyMesh.FromAster('mesh')
nodeGrps = mesh.LIST_GROUP_NO()
for gp in nodeGrps:
    gpName = gp[0]
    if gpName == discreteBalNodes:
        gpNodes = pyMesh.gno.get(gpName)
        nNodesBal = len(gpNodes)
        break

# Acoustic mesh and model
if computeAcoustic:
    grid = LIRE_MAILLAGE(FORMAT='MED', UNITE=19,VERI_MAIL=_F(VERIF='NON'),)
    gridMod = AFFE_MODELE(AFFE=(_F(MODELISATION=('3D', ), PHENOMENE='MECANIQUE', TOUT='OUI'),), MAILLAGE=grid) 

    pyGrid = partition.MAIL_PY()
    pyGrid.FromAster('grid')
    nodeGrpsGrid = grid.LIST_GROUP_NO()


    # if no group of nodes: we will compute all nodes ; create 1 group per node
    if len(nodeGrpsGrid) == 0 or acMeshDim == '2D':
        for grp in nodeGrpsGrid: # if '2D': delete all groups and create one groupe per node
            grpName = grp[0]
            grid = DEFI_GROUP(reuse=grid, MAILLAGE=grid, DETR_GROUP_NO=_F(NOM = grpName))

        grid = DEFI_GROUP(reuse=grid, MAILLAGE=grid, CREA_GROUP_MA=_F(NOM = 'TOUTMA', TOUT = 'OUI'))
        grid = DEFI_GROUP(reuse=grid, MAILLAGE=grid, CREA_GROUP_NO=_F(NOM = 'TOUTNO', GROUP_MA = 'TOUTMA'))

        nNodes = len(pyGrid.cn)
        for node in range(nNodes):
            coords = pyGrid.cn[node]
            if node == 0:
                grid = DEFI_GROUP(reuse=grid, MAILLAGE=grid, CREA_GROUP_NO=_F(GROUP_NO = 'TOUTNO', POSITION = 'INIT' , NOM = 'N'+str(node+1)))
            else:
                grid = DEFI_GROUP(reuse=grid, MAILLAGE=grid, CREA_GROUP_NO=_F(GROUP_NO = 'TOUTNO', NUME_INIT = node+1, NUME_FIN = node+1 , NOM = 'N'+str(node+1)))

        grid = DEFI_GROUP(reuse=grid, MAILLAGE=grid, DETR_GROUP_NO=_F(NOM = 'TOUTNO'))
        grid = DEFI_GROUP(reuse=grid, MAILLAGE=grid, DETR_GROUP_MA=_F(NOM = 'TOUTMA'))

    pyGrid = partition.MAIL_PY()
    pyGrid.FromAster('grid')
    nodeGrpsGrid = grid.LIST_GROUP_NO()

    # create my numerotation reference...
    acousticNodes = []
    for grp in nodeGrpsGrid:
        if grp[1] > 1:
            continue # rule: 1 node per group

        node = {}
        grpName = grp[0]
        grpID = pyGrid.gno.get(grpName)
        nodeID = grpID[0]
        coord = pyGrid.cn[nodeID]

        node = {'name' : grpName, 'ID' : nodeID, 'coords' : coord, 'freqs' : [], 'p_tot_R' : [], 'p_tot_I' : [], 'p_rails_R' : [], 'p_rails_I' : [], 'p_sleepers_R' : [], 'p_sleepers_I' : []}
        acousticNodes.append(node)
        

######################################################
# BOUNDARY CONDITIONS AND INTERACTIONS
######################################################
if USP_on == True:
    tie1 = AFFE_CHAR_MECA(LIAISON_MAIL=(_F(GROUP_NO_ESCL=('USPtop', ), GROUP_MA_MAIT=('setb', ), TYPE_RACCORD='MASSIF', DISTANCE_MAX=1.0)), MODELE=model)
                          
tie2 = AFFE_CHAR_MECA(LIAISON_MAIL=(_F(GROUP_NO_ESCL=('pnts', ), GROUP_MA_MAIT=('setp', ), TYPE_RACCORD='MASSIF', DISTANCE_MAX=1.0)), MODELE=model)
                      
tie3 = AFFE_CHAR_MECA(LIAISON_MAIL=(_F(GROUP_NO_ESCL=('pntr', ), GROUP_MA_MAIT=('retp', ), TYPE_RACCORD='MASSIF', DISTANCE_MAX=1.0)), MODELE=model)
                                    
BCintf = AFFE_CHAR_MECA(MODELE=model, DDL_IMPO=_F(GROUP_NO=('railFt', 'railBk', 'slpSym'),  DX=0.0, DY=0.0, DZ=0.0),)

liaisons_clamps = [_F(GROUP_NO=('clmp_ia0', 'sntria')), _F(GROUP_NO=('clmp_ia1', 'rntsla')), _F(GROUP_NO=('clmp_ib0', 'sntrib')), _F(GROUP_NO=('clmp_ib1', 'rntslb')),
                   _F(GROUP_NO=('clmp_ea0', 'sntrea')), _F(GROUP_NO=('clmp_ea1', 'rntsra')), _F(GROUP_NO=('clmp_eb0', 'sntreb')), _F(GROUP_NO=('clmp_eb1', 'rntsrb'))]

tieClp = AFFE_CHAR_MECA(MODELE=model, LIAISON_SOLIDE=liaisons_clamps,)

if USP_on == True:
    BCs = (BCintf, tie1, tie2, tie3, tieClp)
else:
    BCs = (BCintf, tie2, tie3, tieClp)

# Macroelement 2
if bool_macroEl2_Ph2:
    if USP_on == True:
        tie1_2 = AFFE_CHAR_MECA(LIAISON_MAIL=(_F(GROUP_NO_ESCL=('USPtop', ), GROUP_MA_MAIT=('setb', ), TYPE_RACCORD='MASSIF', DISTANCE_MAX=1.0)), MODELE=model2)
                            
    tie2_2 = AFFE_CHAR_MECA(LIAISON_MAIL=(_F(GROUP_NO_ESCL=('pnts', ), GROUP_MA_MAIT=('setp', ), TYPE_RACCORD='MASSIF', DISTANCE_MAX=1.0)), MODELE=model2)
                        
    tie3_2 = AFFE_CHAR_MECA(LIAISON_MAIL=(_F(GROUP_NO_ESCL=('pntr', ), GROUP_MA_MAIT=('retp', ), TYPE_RACCORD='MASSIF', DISTANCE_MAX=1.0)), MODELE=model2)
                                        
    BCintf2 = AFFE_CHAR_MECA(MODELE=model2, DDL_IMPO=_F(GROUP_NO=('railFt', 'railBk', 'slpSym'), DX=0.0, DY=0.0, DZ=0.0),)

    tieClp2 = AFFE_CHAR_MECA(MODELE=model2, LIAISON_SOLIDE=liaisons_clamps)

    if USP_on == True:
        BCs2 = (BCintf2, tie1_2, tie2_2, tie3_2, tieClp2)
    else:
        BCs2 = (BCintf2, tie2_2, tie3_2, tieClp2)

# Macroelement 2S
if bool_macroEl2_slpShift:
    if USP_on == True:
        tie1_2S = AFFE_CHAR_MECA(LIAISON_MAIL=(_F(GROUP_NO_ESCL=('USPtop', ), GROUP_MA_MAIT=('setb', ), TYPE_RACCORD='MASSIF', DISTANCE_MAX=1.0)), MODELE=model2S)
                            
    tie2_2S = AFFE_CHAR_MECA(LIAISON_MAIL=(_F(GROUP_NO_ESCL=('pnts', ), GROUP_MA_MAIT=('setp', ), TYPE_RACCORD='MASSIF', DISTANCE_MAX=1.0)), MODELE=model2S)
                        
    tie3_2S = AFFE_CHAR_MECA(LIAISON_MAIL=(_F(GROUP_NO_ESCL=('pntr', ), GROUP_MA_MAIT=('retp', ), TYPE_RACCORD='MASSIF', DISTANCE_MAX=1.0)), MODELE=model2S)
                                        
    BCintf2S = AFFE_CHAR_MECA(MODELE=model2S, DDL_IMPO=_F(GROUP_NO=('railFt', 'railBk', 'slpSym'), DX=0.0, DY=0.0, DZ=0.0),)

    tieClp2S = AFFE_CHAR_MECA(MODELE=model2S, LIAISON_SOLIDE=liaisons_clamps)

    if USP_on == True:
        BCs2S = (BCintf2S, tie1_2S, tie2_2S, tie3_2S, tieClp2S)
    else:
        BCs2S = (BCintf2S, tie2_2S, tie3_2S, tieClp2S)

# Force
dirNorm = (fDirVert**2 + fDirLat**2)**(1/2)
fNorm = 100000 # with a too low force value, displacements may be so low that we lose accuracy
fVert = fDirVert/dirNorm*fNorm
fLat = fDirLat/dirNorm*fNorm

load = AFFE_CHAR_MECA(FORCE_NODALE=_F(FX = 0, FY = -fVert, FZ = fLat, GROUP_NO=(nForce, )),
                      MODELE=model)

if bool_macroEl2_Ph2:
    load2 = AFFE_CHAR_MECA(FORCE_NODALE=_F(FX = 0, FY = -fVert, FZ = fLat, GROUP_NO=(nForce, )),
                           MODELE=model2)
    
if bool_macroEl2_slpShift:
    load2S = AFFE_CHAR_MECA(FORCE_NODALE=_F(FX = 0, FY = -fVert, FZ = fLat, GROUP_NO=(nForce, )),
                           MODELE=model2S)


######################################################
# Materials properties ; import functions
######################################################  
# E pad mat 1
f_EPad1=LIRE_FONCTION(UNITE = 30, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')
if bool_macroEl2_Ph2 and 'Emat1' in parameters['macroEl2'].keys():
    fEpad12 = LIRE_FONCTION(UNITE = 50, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')

# E pad mat 2
f_EPad2=LIRE_FONCTION(UNITE = 32, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')
if bool_macroEl2_Ph2 and 'Emat2' in parameters['macroEl2'].keys():
    fEpad22 = LIRE_FONCTION(UNITE = 52, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')

# tanD pad mat 1
f_TDPad1=LIRE_FONCTION(UNITE = 31, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')
if bool_macroEl2_Ph2 and 'tanDmat1' in parameters['macroEl2'].keys():
    fTDpad12=LIRE_FONCTION(UNITE = 54, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')

# tanD pad mat 2
f_TDPad2=LIRE_FONCTION(UNITE = 33, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')
if bool_macroEl2_Ph2 and 'tanDmat2' in parameters['macroEl2'].keys():
    fTDpad22=LIRE_FONCTION(UNITE = 56, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')

if USP_on:
    # E USP
    f_EUSP=LIRE_FONCTION(UNITE = 34, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')
    if bool_macroEl2_Ph2 and 'EUSP' in parameters['macroEl2'].keys():
        f_EUSP2=LIRE_FONCTION(UNITE = 58, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')

    # tanD USP
    f_TDUSP=LIRE_FONCTION(UNITE = 35, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')
    if bool_macroEl2_Ph2 and 'tanDUSP' in parameters['macroEl2'].keys():
        f_TDUSP2=LIRE_FONCTION(UNITE = 60, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')

# E bal
f_EBal=LIRE_FONCTION(UNITE = 36, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')
if bool_macroEl2_Ph2 and 'Ebal' in parameters['macroEl2'].keys():
    f_EBal2=LIRE_FONCTION(UNITE = 62, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')

# tanD bal
f_TDBal=LIRE_FONCTION(UNITE = 37, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')
if bool_macroEl2_Ph2 and 'tanDbal' in parameters['macroEl2'].keys():
    f_TDBal2=LIRE_FONCTION(UNITE = 64, NOM_PARA = 'FREQ', PROL_GAUCHE = 'LINEAIRE', PROL_DROITE = 'LINEAIRE')

######################################################
# Materials properties ; define materials
######################################################  
# Sleeper material ; Before roration: XYZ=LTN ; after rotation (90° Y): XYZ=NTL. See R4.01.02
AB_slprMat = GetAlphaBeta(allFreqsJob, tanDSleeper*np.ones(len(allFreqsJob)))

slprMat = DEFI_MATERIAU(ELAS_ORTH=_F(AMOR_ALPHA=AB_slprMat[0], AMOR_BETA=AB_slprMat[1],
                                     E_L=E1Sleeper, E_N=E3Sleeper, E_T=E2Sleeper,
                                     G_LN=E1Sleeper/2/(1+nuSleeper), G_LT=E1Sleeper/2/(1+nuSleeper), G_TN=E3Sleeper/2/(1+nuSleeper),
                                     NU_LN=nuSleeper, NU_LT=nuSleeper, NU_TN=nuSleeper,
                                     RHO=rhoSleeper*1e-12))

# Sleeper material macroEl2
if bool_macroEl2_Ph2:
    E1slp = parameters["macroEl2"].get("E1Sleeper") if parameters["macroEl2"].get("E1Sleeper") is not None else E1Sleeper
    E2slp = parameters["macroEl2"].get("E2Sleeper") if parameters["macroEl2"].get("E2Sleeper") is not None else E2Sleeper
    E3slp = parameters["macroEl2"].get("E3Sleeper") if parameters["macroEl2"].get("E3Sleeper") is not None else E3Sleeper
    nuSlp = parameters["macroEl2"].get("nuSleeper") if parameters["macroEl2"].get("nuSleeper") is not None else nuSleeper
    rhoSlp = parameters["macroEl2"].get("rhoSleeper") if parameters["macroEl2"].get("rhoSleeper") is not None else rhoSleeper
    tanDSlp = parameters["macroEl2"].get("tanDSleeper") if parameters["macroEl2"].get("tanDSleeper") is not None else tanDSleeper
    AB_slp = GetAlphaBeta(allFreqsJob, tanDSlp*np.ones(len(allFreqsJob)))

    slprMat2 = DEFI_MATERIAU(ELAS_ORTH=_F(AMOR_ALPHA=AB_slp[0], AMOR_BETA=AB_slp[1],
                                          E_L=E1slp, E_N=E3slp, E_T=E2slp,
                                          G_LN=E1slp/2/(1+nuSlp), G_LT=E1slp/2/(1+nuSlp), G_TN=E3slp/2/(1+nuSlp),
                                          NU_LN=nuSlp, NU_LT=nuSlp, NU_TN=nuSlp,
                                          RHO=rhoSlp*1e-12))

# Rail material
AB_railMat = GetAlphaBeta(allFreqsJob, tanDRail*np.ones(len(allFreqsJob)))

railMat = DEFI_MATERIAU(ELAS=_F(AMOR_ALPHA=AB_railMat[0], AMOR_BETA=AB_railMat[1],
                                E=ERail, NU=nuRail, RHO=rhoRail*1e-12))

# Pad material 1
eta_padMat1 = np.array([f_TDPad1(f) for f in allFreqsJob])
AB_padMat1 = GetAlphaBeta(allFreqsJob, eta_padMat1)

padMat1 = DEFI_MATERIAU(ELAS=_F(AMOR_ALPHA=AB_padMat1[0], AMOR_BETA=AB_padMat1[1],
                                E=f_EPad1(meanFreqJob)/scaling_slpX, NU=nuPadMat1, RHO=1.0e-09))

# Pad material 1 macroEl2
if bool_macroEl2_Ph2:
    try:
        Epad = fEpad12(meanFreqJob)
    except:
        Epad = f_EPad1(meanFreqJob)

    try:
        eta_pad1 = np.array([fTDpad12(f) for f in allFreqsJob])
    except:
        eta_pad1 = np.array([f_TDPad1(f) for f in allFreqsJob])
    
    nuPad = parameters["macroEl2"].get("nuMat1") if parameters["macroEl2"].get("nuMat1") is not None else nuPadMat1
    AB_pad1 = GetAlphaBeta(allFreqsJob, eta_pad1)

    padMat12 = DEFI_MATERIAU(ELAS=_F(AMOR_ALPHA=AB_pad1[0], AMOR_BETA=AB_pad1[1],
                                     E=Epad/scaling_slpX, NU=nuPad, RHO=1.0e-09))

# Pad material 2
eta_padMat2 = np.array([f_TDPad2(f) for f in allFreqsJob])
AB_padMat2 = GetAlphaBeta(allFreqsJob, eta_padMat2)

padMat2 = DEFI_MATERIAU(ELAS=_F(AMOR_ALPHA=AB_padMat2[0], AMOR_BETA=AB_padMat2[1],
                                E=f_EPad2(meanFreqJob)/scaling_slpX, NU=nuPadMat2, RHO=1.0e-09))

# Pad material 2 macroEl2
if bool_macroEl2_Ph2:
    try:
        Epad = fEpad22(meanFreqJob)
    except:
        Epad = f_EPad2(meanFreqJob)

    try:
        eta_pad2 = np.array([fTDpad22(f) for f in allFreqsJob])
    except:
        eta_pad2 = np.array([f_TDPad2(f) for f in allFreqsJob])
    
    nuPad = parameters["macroEl2"].get("nuMat2") if parameters["macroEl2"].get("nuMat2") is not None else nuPadMat2
    AB_pad2 = GetAlphaBeta(allFreqsJob, eta_pad2)

    padMat22 = DEFI_MATERIAU(ELAS=_F(AMOR_ALPHA=AB_pad2[0], AMOR_BETA=AB_pad2[1],
                                     E=Epad/scaling_slpX, NU=nuPad, RHO=1.0e-09))

# USP material
if USP_on:
    eta_USP = np.array([f_TDUSP(f) for f in allFreqsJob])
    AB_USP = GetAlphaBeta(allFreqsJob, eta_USP)
 
    USPmat = DEFI_MATERIAU(ELAS=_F(AMOR_ALPHA=AB_USP[0], AMOR_BETA=AB_USP[1],
                                   E=f_EUSP(meanFreqJob)/scaling_slpX, NU=nuUSP, RHO=0.375e-09)) 
    
    # USP material macroEl2
    if bool_macroEl2_Ph2:
        try:
            EUSP = f_EUSP2(meanFreqJob)
        except:
            EUSP = f_EUSP(meanFreqJob)

        try:
            eta_USP = np.array([f_TDUSP2(f) for f in allFreqsJob])
        except:
            eta_USP = np.array([f_TDUSP(f) for f in allFreqsJob])
    
        nuUSP2 = parameters["macroEl2"].get("nuUSP") if parameters["macroEl2"].get("nuUSP") is not None else nuUSP
        AB_USP = GetAlphaBeta(allFreqsJob, eta_USP)

        USPmat2 = DEFI_MATERIAU(ELAS=_F(AMOR_ALPHA=AB_USP[0], AMOR_BETA=AB_USP[1],
                                        E=EUSP/scaling_slpX, NU=nuUSP2, RHO=0.375e-09)) 

######################################################
# Materials properties affectation
######################################################  
# Material affectation macroelement 1
affeMat = [_F(GROUP_MA=('sleepere'), MATER=(slprMat, )),
           _F(GROUP_MA=('hard'), MATER=(padMat1, )),
           _F(GROUP_MA=('soft'), MATER=(padMat2, )),
           _F(GROUP_MA=('raile'), MATER=(railMat, ))]

if USP_on:
    affeMat.append(_F(GROUP_MA=('USPe'), MATER=(USPmat, )),)

fldMat = AFFE_MATERIAU(AFFE=affeMat, MAILLAGE=mesh, MODELE=model,)

# Material affectation macroelement 2
if bool_macroEl2_Ph2:
    affeMat = [_F(GROUP_MA=('sleepere'), MATER=(slprMat2, )),
              _F(GROUP_MA=('hard'), MATER=(padMat12, )),
              _F(GROUP_MA=('soft'), MATER=(padMat22, )),
              _F(GROUP_MA=('raile'), MATER=(railMat, ))]

    if USP_on:
        affeMat.append(_F(GROUP_MA=('USPe'), MATER=(USPmat2, )),)

    fldMat2 = AFFE_MATERIAU(AFFE=affeMat, MAILLAGE=mesh2, MODELE=model2,)

# Material affectation macroelement 2S
if bool_macroEl2_slpShift:
    fldMat2S = AFFE_MATERIAU(AFFE=affeMat, MAILLAGE=mesh2S, MODELE=model2S,)

                    
######################################################
# Ballast properties calculation & affectation (discrete)
###################################################### 
nodeStiff_Y = f_EBal(meanFreqJob)*(coefSlpBotArea*A_slpBot)/(1000*hBal)/nNodesBal
nodeStiff_XZ = f_EBal(meanFreqJob)/2/(1+nuBal)*(coefSlpBotArea*A_slpBot)/(1000*hBal)/nNodesBal
nodeAmo_Y = nodeStiff_Y*f_TDBal(meanFreqJob)/(2*math.pi*meanFreqJob)
nodeAmo_XZ = nodeStiff_XZ*f_TDBal(meanFreqJob)/(2*math.pi*meanFreqJob)

# Ballast discrete elements ; macroEl2
if bool_macroEl2_Ph2:
    try:
        Ebal = f_EBal2(meanFreqJob)
    except:
        Ebal = f_EBal(meanFreqJob)

    try:
        tanDbal = f_TDBal2(meanFreqJob)
    except:
        tanDbal = f_TDBal(meanFreqJob)

    nuBal2 = parameters["macroEl2"].get("nuBal") if parameters["macroEl2"].get("nuBal") is not None else nuBal

    nodeStiff_Y2 = Ebal*(coefSlpBotArea*A_slpBot)/(1000*hBal)/nNodesBal
    nodeStiff_XZ2 = Ebal/2/(1+nuBal2)*(coefSlpBotArea*A_slpBot)/(1000*hBal)/nNodesBal
    nodeAmo_Y2 = nodeStiff_Y2*tanDbal/(2*math.pi*meanFreqJob)
    nodeAmo_XZ2 = nodeStiff_XZ2*tanDbal/(2*math.pi*meanFreqJob)

# Ballast & clamps discrete elements affectation
elProp = AFFE_CARA_ELEM(DISCRET=(_F(CARA='K_T_D_N', GROUP_MA=(discreteBalNodes+'0D'), VALE=(nodeStiff_XZ, nodeStiff_Y, nodeStiff_XZ),),
                                   _F(CARA='M_T_D_N', GROUP_MA=(discreteBalNodes+'0D'), VALE=0),
                                   _F(CARA='A_T_D_N', GROUP_MA=(discreteBalNodes+'0D'), VALE=(nodeAmo_XZ, nodeAmo_Y, nodeAmo_XZ)),
                                   _F(CARA='K_T_D_L', GROUP_MA=('clmp_ia', 'clmp_ib', 'clmp_ea', 'clmp_eb'), VALE=(clampStiffX,clampStiffY,clampStiffZ)),
                                   _F(CARA='A_T_D_L', GROUP_MA=('clmp_ia', 'clmp_ib', 'clmp_ea', 'clmp_eb'), VALE=(clampDampX,clampDampY,clampDampZ)),),
                          # Before roration: XYZ=LTN ; after rotation (90° Y): XYZ=NTL.
                          MASSIF=_F(ANGL_REP=(0.0, 90.0, 0.0), GROUP_MA=('sleepere', )),
                          MODELE=model)

# Ballast & clamps discrete elements affectation ; macroEl2
if bool_macroEl2_Ph2:
    clampStiffX2 = parameters["macroEl2"].get("clampStiffX")*1000/2 if parameters["macroEl2"].get("clampStiffX") is not None else clampStiffX
    clampStiffY2 = parameters["macroEl2"].get("clampStiffY")*1000/2 if parameters["macroEl2"].get("clampStiffY") is not None else clampStiffY
    clampStiffZ2 = parameters["macroEl2"].get("clampStiffZ")*1000/2 if parameters["macroEl2"].get("clampStiffZ") is not None else clampStiffZ
    clampDampX2 = parameters["macroEl2"].get("clampDampX")/2 if parameters["macroEl2"].get("clampDampX") is not None else clampDampX
    clampDampY2 = parameters["macroEl2"].get("clampDampY")/2 if parameters["macroEl2"].get("clampDampY") is not None else clampDampY
    clampDampZ2 = parameters["macroEl2"].get("clampDampZ")/2 if parameters["macroEl2"].get("clampDampZ") is not None else clampDampZ

    elProp2 = AFFE_CARA_ELEM(DISCRET=(_F(CARA='K_T_D_N', GROUP_MA=(discreteBalNodes+'0D'), VALE=(nodeStiff_XZ2, nodeStiff_Y2, nodeStiff_XZ2),),
                                       _F(CARA='M_T_D_N', GROUP_MA=(discreteBalNodes+'0D'), VALE=0),
                                       _F(CARA='A_T_D_N', GROUP_MA=(discreteBalNodes+'0D'), VALE=(nodeAmo_XZ2, nodeAmo_Y2, nodeAmo_XZ2)),
                                       _F(CARA='K_T_D_L', GROUP_MA=('clmp_ia', 'clmp_ib', 'clmp_ea', 'clmp_eb'), VALE=(clampStiffX2,clampStiffY2,clampStiffZ2)),
                                       _F(CARA='A_T_D_L', GROUP_MA=('clmp_ia', 'clmp_ib', 'clmp_ea', 'clmp_eb'), VALE=(clampDampX2,clampDampY2,clampDampZ2)),),
                              MASSIF=_F(ANGL_REP=(0.0, 90.0, 0.0), GROUP_MA=('sleepere', )),
                              MODELE=model2)
    
# Ballast & clamps discrete elements affectation ; macroEl2S
if bool_macroEl2_slpShift:
    elProp2S = AFFE_CARA_ELEM(DISCRET=(_F(CARA='K_T_D_N', GROUP_MA=(discreteBalNodes+'0D'), VALE=(nodeStiff_XZ2, nodeStiff_Y2, nodeStiff_XZ2),),
                                       _F(CARA='M_T_D_N', GROUP_MA=(discreteBalNodes+'0D'), VALE=0),
                                       _F(CARA='A_T_D_N', GROUP_MA=(discreteBalNodes+'0D'), VALE=(nodeAmo_XZ2, nodeAmo_Y2, nodeAmo_XZ2)),
                                       _F(CARA='K_T_D_L', GROUP_MA=('clmp_ia', 'clmp_ib', 'clmp_ea', 'clmp_eb'), VALE=(clampStiffX2,clampStiffY2,clampStiffZ2)),
                                       _F(CARA='A_T_D_L', GROUP_MA=('clmp_ia', 'clmp_ib', 'clmp_ea', 'clmp_eb'), VALE=(clampDampX2,clampDampY2,clampDampZ2)),),
                              MASSIF=_F(ANGL_REP=(0.0, 90.0, 0.0), GROUP_MA=('sleepere', )),
                              MODELE=model2S)

######################################################
# Get eigenshapes computed in phase 1 and trim them to make a light modal basis
######################################################
# (if done after assembling matrices, it makes a weird error, idky...)
print('Nominal macroelement')
listEigenModes = GetEigenModesList('fort.7', cumulX_mini, cumulY_mini, cumulZ_mini)
mod_trim = EXTR_MODE(FILTRE_MODE = _F(MODE=mdPh1, NUME_MODE=listEigenModes))

if bool_macroEl2_Ph2 and bool_macroEl2_Ph1:
        # if we want to make a macroelement 2, and if mode shapes for this macroelement are available from phase 1
        print('2nd macroelement')
        listEigenModes2 = GetEigenModesList('fort.8', cumulX_mini, cumulY_mini, cumulZ_mini)
        mdTrim2 = EXTR_MODE(FILTRE_MODE = _F(MODE=mdPh1_2, NUME_MODE=listEigenModes2))

if bool_macroEl2_slpShift:
        mdTrim2S = EXTR_MODE(FILTRE_MODE = _F(MODE=mdPh1_2S, NUME_MODE=listEigenModes2))
    
######################################################
# Compute elementary matrices & assemble
######################################################
# Stiffness matrix (nominal)
K_el = CALC_MATR_ELEM(MODELE=model, CHAM_MATER=fldMat, OPTION='RIGI_MECA', CHARGE=BCs, CARA_ELEM=elProp)
num2 = NUME_DDL(MATR_RIGI=K_el)
K_as = ASSE_MATRICE(MATR_ELEM=K_el, NUME_DDL=num2)

# Stiffness matrix (macroEl2)
if bool_macroEl2_Ph2:
    K_el2 = CALC_MATR_ELEM(MODELE=model2, CHAM_MATER=fldMat2, OPTION='RIGI_MECA', CHARGE=BCs2, CARA_ELEM=elProp2)
    num2_2 = NUME_DDL(MATR_RIGI=K_el2)
    K_as2 = ASSE_MATRICE(MATR_ELEM=K_el2, NUME_DDL=num2_2)

# Stiffness matrix (macroEl2S)
if bool_macroEl2_slpShift:
    K_el2S = CALC_MATR_ELEM(MODELE=model2S, CHAM_MATER=fldMat2S, OPTION='RIGI_MECA', CHARGE=BCs2S, CARA_ELEM=elProp2S)
    num2_2S = NUME_DDL(MATR_RIGI=K_el2S)
    K_as2S = ASSE_MATRICE(MATR_ELEM=K_el2S, NUME_DDL=num2_2S)

# Mass matrix (nominal)
M_el = CALC_MATR_ELEM(MODELE=model, CHAM_MATER=fldMat, OPTION='MASS_MECA', CHARGE=BCs, CARA_ELEM=elProp)
M_as = ASSE_MATRICE(MATR_ELEM=M_el, NUME_DDL=num2)

# Mass matrix (macroEl2)
if bool_macroEl2_Ph2:
    M_el2 = CALC_MATR_ELEM(MODELE=model2, CHAM_MATER=fldMat2, OPTION='MASS_MECA', CHARGE=BCs2, CARA_ELEM=elProp2)
    M_as2 = ASSE_MATRICE(MATR_ELEM=M_el2, NUME_DDL=num2_2)

# Mass matrix (macroEl2S)
if bool_macroEl2_slpShift:
    M_el2S = CALC_MATR_ELEM(MODELE=model2S, CHAM_MATER=fldMat2S, OPTION='MASS_MECA', CHARGE=BCs2S, CARA_ELEM=elProp2S)
    M_as2S = ASSE_MATRICE(MATR_ELEM=M_el2S, NUME_DDL=num2_2S)

# Damping matrix (nominal)
A_el = CALC_MATR_ELEM(MODELE=model, RIGI_MECA=K_el, MASS_MECA=M_el, CHAM_MATER=fldMat, OPTION='AMOR_MECA', CHARGE=BCs, CARA_ELEM=elProp)
A_as = ASSE_MATRICE(MATR_ELEM=A_el, NUME_DDL=num2)

# Damping matrix (macroEl2)
if bool_macroEl2_Ph2:
    A_el2 = CALC_MATR_ELEM(MODELE=model2, RIGI_MECA=K_el2, MASS_MECA=M_el2, CHAM_MATER=fldMat2, OPTION='AMOR_MECA', CHARGE=BCs2, CARA_ELEM=elProp2)
    A_as2 = ASSE_MATRICE(MATR_ELEM=A_el2, NUME_DDL=num2_2)

# Damping matrix (macroEl2S)
if bool_macroEl2_slpShift:
    A_el2S = CALC_MATR_ELEM(MODELE=model2S, RIGI_MECA=K_el2S, MASS_MECA=M_el2S, CHAM_MATER=fldMat2S, OPTION='AMOR_MECA', CHARGE=BCs2S, CARA_ELEM=elProp2S)
    A_as2S = ASSE_MATRICE(MATR_ELEM=A_el2S, NUME_DDL=num2_2S)  

# Force vector (nominal)
vectEl = CALC_VECT_ELEM(OPTION='CHAR_MECA', CHARGE=load, CARA_ELEM=elProp)
vectAs = ASSE_VECTEUR(VECT_ELEM=vectEl, NUME_DDL=num2)

# Force vector (macroEl2)
if bool_macroEl2_Ph2:
    vectEl2 = CALC_VECT_ELEM(OPTION='CHAR_MECA', CHARGE=load2, CARA_ELEM=elProp2)
    vectAs2 = ASSE_VECTEUR(VECT_ELEM=vectEl2, NUME_DDL=num2_2)

# Force vector (macroEl2S)
if bool_macroEl2_slpShift:
    vectEl2S = CALC_VECT_ELEM(OPTION='CHAR_MECA', CHARGE=load2S, CARA_ELEM=elProp2S)
    vectAs2S = ASSE_VECTEUR(VECT_ELEM=vectEl2S, NUME_DDL=num2_2S)

######################################################
# Compute eigen modes using projection on modal basis + QZ method
######################################################
bmRef = DEFI_BASE_MODALE(RITZ = _F(MODE_MECA=mod_trim))

ndlGen = NUME_DDL_GENE(BASE=bmRef, STOCKAGE= 'PLEIN',);

K_gene = PROJ_MATR_BASE(BASE = bmRef, NUME_DDL_GENE = ndlGen, MATR_ASSE = K_as)

M_gene = PROJ_MATR_BASE(BASE = bmRef, NUME_DDL_GENE = ndlGen, MATR_ASSE = M_as)
               
modGen=CALC_MODES(TYPE_RESU='DYNAMIQUE', MATR_RIGI=K_gene, MATR_MASS=M_gene, OPTION='TOUT', SOLVEUR_MODAL=_F(METHODE='QZ'), VERI_MODE=_F(STOP_ERREUR='NON',))

mdPh2 = REST_GENE_PHYS(RESU_GENE=modGen, NUME_DDL=num2)

# macroelement 2
if bool_macroEl2_Ph2:
    if bool_macroEl2_Ph1:
        # mode shapes for macroEl2 were computed ; we project K, M on corresponding trimmed modal basis
        bmRef2 = DEFI_BASE_MODALE(RITZ = _F(MODE_MECA=mdTrim2))
        ndlGen2 = NUME_DDL_GENE(BASE=bmRef2, STOCKAGE= 'PLEIN',)
        K_gen2 = PROJ_MATR_BASE(BASE = bmRef2, NUME_DDL_GENE = ndlGen2, MATR_ASSE = K_as2)
        M_gen2 = PROJ_MATR_BASE(BASE = bmRef2, NUME_DDL_GENE = ndlGen2, MATR_ASSE = M_as2)
    else:
        # mode shapes for macroEl2 were not computed ; we project K, M on nominal macroelement trimmed modal basis
        K_gen2 = PROJ_MATR_BASE(BASE = bmRef, NUME_DDL_GENE = ndlGen, MATR_ASSE = K_as2)
        M_gen2 = PROJ_MATR_BASE(BASE = bmRef, NUME_DDL_GENE = ndlGen, MATR_ASSE = M_as2)

    modGen2 = CALC_MODES(TYPE_RESU='DYNAMIQUE', MATR_RIGI=K_gen2, MATR_MASS=M_gen2, OPTION='TOUT', SOLVEUR_MODAL=_F(METHODE='QZ'), VERI_MODE=_F(STOP_ERREUR='NON',))
    mdPh2_2 = REST_GENE_PHYS(RESU_GENE=modGen2, NUME_DDL=num2_2)

# macroelement 2S
if bool_macroEl2_slpShift:
    # mode shapes for macroEl2S were obviously computed ; we project K, M on corresponding trimmed modal basis
    bmRef2S = DEFI_BASE_MODALE(RITZ = _F(MODE_MECA=mdTrim2S))
    ndlGen2S = NUME_DDL_GENE(BASE=bmRef2S, STOCKAGE= 'PLEIN',)
    K_gen2S = PROJ_MATR_BASE(BASE = bmRef2S, NUME_DDL_GENE = ndlGen2S, MATR_ASSE = K_as2S)
    M_gen2S = PROJ_MATR_BASE(BASE = bmRef2S, NUME_DDL_GENE = ndlGen2S, MATR_ASSE = M_as2S)

    modGen2S = CALC_MODES(TYPE_RESU='DYNAMIQUE', MATR_RIGI=K_gen2S, MATR_MASS=M_gen2S, OPTION='TOUT', SOLVEUR_MODAL=_F(METHODE='QZ'), VERI_MODE=_F(STOP_ERREUR='NON',))
    mdPh2_2S = REST_GENE_PHYS(RESU_GENE=modGen2S, NUME_DDL=num2_2S)

######################################################
# Compute static interface modes
######################################################
modStaR1 = MODE_STATIQUE(MATR_RIGI=K_as, MATR_MASS=M_as,
                         MODE_INTERF=_F(GROUP_NO = 'railBk', TOUT_CMP='OUI', NB_MODE=nModesRai, SHIFT=10,),)

modStaR2 = MODE_STATIQUE(MATR_RIGI=K_as, MATR_MASS=M_as,
                         MODE_INTERF=_F(GROUP_NO = 'railFt', TOUT_CMP='OUI', NB_MODE=nModesRai, SHIFT=10,),)

modStaS = MODE_STATIQUE(MATR_RIGI=K_as, MATR_MASS=M_as,
                        MODE_INTERF=_F(GROUP_NO = 'slpSym', TOUT_CMP='OUI', NB_MODE=nModesSlp, SHIFT=100,),)

# Normalize static modes
modStaR1 = NORM_MODE(reuse=modStaR1, MODE=modStaR1, NORME='TRAN')
modStaR2 = NORM_MODE(reuse=modStaR2, MODE=modStaR2, NORME='TRAN')
modStaS = NORM_MODE(reuse=modStaS, MODE=modStaS, NORME='TRAN', INFO=2)

# Define dynamic interfaces   
Lint = DEFI_INTERF_DYNA(NUME_DDL=num1, 
                        INTERFACE=(_F(NOM = 'I_slpSym', TYPE = 'CRAIGB', GROUP_NO = 'slpSym'),
                                   _F(NOM = 'I_raiRBk', TYPE = 'CRAIGB', GROUP_NO = 'railBk'),
                                   _F(NOM = 'I_raiRFt', TYPE = 'CRAIGB', GROUP_NO = 'railFt'),))

# macroelement 2
if bool_macroEl2_Ph2:
    modR1_2 = MODE_STATIQUE(MATR_RIGI=K_as2, MATR_MASS=M_as2,
                            MODE_INTERF=_F(GROUP_NO = 'railBk', TOUT_CMP='OUI', NB_MODE=nModesRai, SHIFT=10,),)

    modR2_2 = MODE_STATIQUE(MATR_RIGI=K_as2, MATR_MASS=M_as2,
                            MODE_INTERF=_F(GROUP_NO = 'railFt', TOUT_CMP='OUI', NB_MODE=nModesRai, SHIFT=10,),)

    modS_2 = MODE_STATIQUE(MATR_RIGI=K_as2, MATR_MASS=M_as2,
                           MODE_INTERF=_F(GROUP_NO = 'slpSym', TOUT_CMP='OUI', NB_MODE=nModesSlp, SHIFT=100,),)

    # Normalize static modes
    modR1_2 = NORM_MODE(reuse=modR1_2, MODE=modR1_2, NORME='TRAN')
    modR2_2 = NORM_MODE(reuse=modR2_2, MODE=modR2_2, NORME='TRAN')
    modS_2 = NORM_MODE(reuse=modS_2, MODE=modS_2, NORME='TRAN')

    # Define dynamic interfaces   
    Lint2 = DEFI_INTERF_DYNA(NUME_DDL=num1_2, 
                             INTERFACE=(_F(NOM = 'I_slpSym', TYPE = 'CRAIGB', GROUP_NO = 'slpSym'),
                                        _F(NOM = 'I_raiRBk', TYPE = 'CRAIGB', GROUP_NO = 'railBk'),
                                        _F(NOM = 'I_raiRFt', TYPE = 'CRAIGB', GROUP_NO = 'railFt'),))

# macroelement 2S
if bool_macroEl2_slpShift:
    modR1_2S = MODE_STATIQUE(MATR_RIGI=K_as2S, MATR_MASS=M_as2S,
                            MODE_INTERF=_F(GROUP_NO = 'railBk', TOUT_CMP='OUI', NB_MODE=nModesRai, SHIFT=10,),)

    modR2_2S = MODE_STATIQUE(MATR_RIGI=K_as2S, MATR_MASS=M_as2S,
                            MODE_INTERF=_F(GROUP_NO = 'railFt', TOUT_CMP='OUI', NB_MODE=nModesRai, SHIFT=10,),)

    modS_2S = MODE_STATIQUE(MATR_RIGI=K_as2S, MATR_MASS=M_as2S,
                           MODE_INTERF=_F(GROUP_NO = 'slpSym', TOUT_CMP='OUI', NB_MODE=nModesSlp, SHIFT=100,),)

    # Normalize static modes
    modR1_2S = NORM_MODE(reuse=modR1_2S, MODE=modR1_2S, NORME='TRAN')
    modR2_2S = NORM_MODE(reuse=modR2_2S, MODE=modR2_2S, NORME='TRAN')
    modS_2S = NORM_MODE(reuse=modS_2S, MODE=modS_2S, NORME='TRAN')

    # Define dynamic interfaces   
    Lint2S = DEFI_INTERF_DYNA(NUME_DDL=num1_2S, 
                              INTERFACE=(_F(NOM = 'I_slpSym', TYPE = 'CRAIGB', GROUP_NO = 'slpSym'),
                                         _F(NOM = 'I_raiRBk', TYPE = 'CRAIGB', GROUP_NO = 'railBk'),
                                         _F(NOM = 'I_raiRFt', TYPE = 'CRAIGB', GROUP_NO = 'railFt'),))

######################################################
# Create modal basis
######################################################      
bamo1 = DEFI_BASE_MODALE(RITZ=(_F(MODE_MECA = mdPh2, ), _F(MODE_INTF = modStaR1, )), INTERF_DYNA=Lint, NUME_REF=num2)
bamo1 = DEFI_BASE_MODALE(reuse=bamo1, RITZ=(_F(BASE_MODALE=bamo1), _F(MODE_INTF = modStaR2, )), NUME_REF=num2)
bamo1 = DEFI_BASE_MODALE(reuse=bamo1, RITZ=(_F(BASE_MODALE=bamo1), _F(MODE_INTF = modStaS, )), NUME_REF=num2)

if bool_macroEl2_Ph2:
    bamo1_2 = DEFI_BASE_MODALE(RITZ=(_F(MODE_MECA = mdPh2_2, ), _F(MODE_INTF = modR1_2, )), INTERF_DYNA=Lint2, NUME_REF=num2_2)
    bamo1_2 = DEFI_BASE_MODALE(reuse=bamo1_2, RITZ=(_F(BASE_MODALE=bamo1_2), _F(MODE_INTF = modR2_2, )), NUME_REF=num2_2)
    bamo1_2 = DEFI_BASE_MODALE(reuse=bamo1_2, RITZ=(_F(BASE_MODALE=bamo1_2), _F(MODE_INTF = modS_2, )), NUME_REF=num2_2)

if bool_macroEl2_slpShift:
    bamo1_2S = DEFI_BASE_MODALE(RITZ=(_F(MODE_MECA = mdPh2_2S, ), _F(MODE_INTF = modR1_2S, )), INTERF_DYNA=Lint2S, NUME_REF=num2_2S)
    bamo1_2S = DEFI_BASE_MODALE(reuse=bamo1_2S, RITZ=(_F(BASE_MODALE=bamo1_2S), _F(MODE_INTF = modR2_2S, )), NUME_REF=num2_2S)
    bamo1_2S = DEFI_BASE_MODALE(reuse=bamo1_2S, RITZ=(_F(BASE_MODALE=bamo1_2S), _F(MODE_INTF = modS_2S, )), NUME_REF=num2_2S)

# Add compression static mode
# mstat = MODE_STATIQUE (MATR_RIGI = K_as, FORCE_NODALE =_F(GROUP_NO = 'nAbvSlp', AVEC_CMP =('DY'),),)
# bamo1=DEFI_BASE_MODALE(reuse=bamo1, RITZ=(_F(BASE_MODALE=bamo1), _F(MODE_INTF = mstat, )), NUME_REF=num2)

######################################################
# Create macro element
######################################################
mcroEl1 = MACR_ELEM_DYNA(BASE_MODALE=bamo1, MATR_MASS=M_as, MATR_RIGI=K_as, MATR_AMOR=A_as)

if bool_macroEl2_Ph2:
    mcroEl2 = MACR_ELEM_DYNA(BASE_MODALE=bamo1_2, MATR_MASS=M_as2, MATR_RIGI=K_as2, MATR_AMOR=A_as2)

if bool_macroEl2_slpShift:
    mcroEl2S = MACR_ELEM_DYNA(BASE_MODALE=bamo1_2S, MATR_MASS=M_as2S, MATR_RIGI=K_as2S, MATR_AMOR=A_as2S)
                          

######################################################
# Macroelements coupling and generalized model creation
######################################################
substructs = []
liaisons = []
for i in range(nSlp):
    if ('macroElSequence' not in parameters) or (not bool_macroEl2_Ph2) or (parameters['macroElSequence'][i] == 1):
        substR = _F(NOM = 'elem'+str(i)+'R', MACR_ELEM_DYNA = mcroEl1, ANGL_NAUT = (0., 0., 0.), TRANS=(i*slpSpacing,0.,0.))
        substL = _F(NOM = 'elem'+str(i)+'L', MACR_ELEM_DYNA = mcroEl1, ANGL_NAUT = (0., 180., 0.), TRANS=(i*slpSpacing,0.,0.))
    else:
        macroElNbr = parameters['macroElSequence'][i]
        if macroElNbr == 2:
            substR = _F(NOM = 'elem'+str(i)+'R', MACR_ELEM_DYNA = mcroEl2, ANGL_NAUT = (0., 0., 0.), TRANS=(i*slpSpacing,0.,0.))
            if bool_macroEl2_slpShift:
                substL = _F(NOM = 'elem'+str(i)+'L', MACR_ELEM_DYNA = mcroEl2S, ANGL_NAUT = (0., 180., 0.), TRANS=(i*slpSpacing,0.,0.))
            else:
                substL = _F(NOM = 'elem'+str(i)+'L', MACR_ELEM_DYNA = mcroEl2, ANGL_NAUT = (0., 180., 0.), TRANS=(i*slpSpacing,0.,0.))
        elif macroElNbr == 3:
            substR = _F(NOM = 'elem'+str(i)+'R', MACR_ELEM_DYNA = mcroEl2S, ANGL_NAUT = (0., 0., 0.), TRANS=(i*slpSpacing,0.,0.))
            substL = _F(NOM = 'elem'+str(i)+'L', MACR_ELEM_DYNA = mcroEl2, ANGL_NAUT = (0., 180., 0.), TRANS=(i*slpSpacing,0.,0.))

    substructs.append(substR)
    substructs.append(substL)
    
    liais2 = _F(SOUS_STRUC_1 = 'elem'+str(i)+'R', SOUS_STRUC_2 = 'elem'+str(i)+'L', INTERFACE_1  = 'I_slpSym', INTERFACE_2  = 'I_slpSym', OPTION='REDUIT')
    liaisons.append(liais2)
    
    if i != nSlp-1:
        liais4 = _F(SOUS_STRUC_1 = 'elem'+str(i)+'R', SOUS_STRUC_2 = 'elem'+str(i+1)+'R', INTERFACE_1 = 'I_raiRFt', INTERFACE_2 = 'I_raiRBk', OPTION='REDUIT')
        liais6 = _F(SOUS_STRUC_1 = 'elem'+str(i)+'L', SOUS_STRUC_2 = 'elem'+str(i+1)+'L', INTERFACE_1 = 'I_raiRBk', INTERFACE_2 = 'I_raiRFt', OPTION='REDUIT')
        liaisons.append(liais4)
        liaisons.append(liais6)

modeGene = DEFI_MODELE_GENE(SOUS_STRUC=substructs, LIAISON=liaisons, VERIF=_F(STOP_ERREUR = 'OUI', PRECISION = 1.E-6, CRITERE = 'RELATIF'))
numGene = NUME_DDL_GENE(MODELE_GENE=modeGene)

######################################################
# ASSEMBLAGE DES MATRICES RAIDEUR ET MASSE GENERALISEES STATIQUES
######################################################
masGene=ASSE_MATR_GENE(NUME_DDL_GENE=numGene, OPTION='MASS_GENE');

rigGene=ASSE_MATR_GENE(NUME_DDL_GENE=numGene, OPTION='RIGI_GENE');
                                  
amoGene=ASSE_MATR_GENE(NUME_DDL_GENE=numGene, OPTION='AMOR_GENE');

if bool_macroEl2_Ph2 is False or 'macroElSequence' not in parameters or parameters['macroElSequence'][slpForce-1] == 1:  
    vectGene=ASSE_VECT_GENE(NUME_DDL_GENE=numGene,CHAR_SOUS_STRUC=(_F(SOUS_STRUC = 'elem'+str(slpForce-1)+'R',VECT_ASSE = vectAs),))
elif parameters['macroElSequence'][slpForce-1] == 2:
    vectGene=ASSE_VECT_GENE(NUME_DDL_GENE=numGene,CHAR_SOUS_STRUC=(_F(SOUS_STRUC = 'elem'+str(slpForce-1)+'R',VECT_ASSE = vectAs2),))
elif parameters['macroElSequence'][slpForce-1] == 3:
    vectGene=ASSE_VECT_GENE(NUME_DDL_GENE=numGene,CHAR_SOUS_STRUC=(_F(SOUS_STRUC = 'elem'+str(slpForce-1)+'R',VECT_ASSE = vectAs2S),))
                
######################################################
# HARMONIC SIMULATION
######################################################
harmGene = DYNA_VIBRA(BASE_CALCUL='GENE',
                      TYPE_CALCUL='HARM',
                      MATR_MASS=masGene,
                      MATR_RIGI=rigGene,
                      MATR_AMOR=amoGene,
                      FREQ=allFreqsJob,
                      TOUT_CHAM='OUI', #NOM_CHAM=('DEPL', 'VITE', 'ACCE'),
                      EXCIT=_F(VECT_ASSE_GENE=vectGene, COEF_MULT=1.0,),
                      SOLVEUR=_F(METHODE='MUMPS', ELIM_LAGR='NON',),)


######################################################
# Acoustic parameters / functions definition
# More comments available in the 3-sleeper model command file
######################################################
if computeAcoustic == True:
    c = 343.0
    rho = 1.21
    dirContribs = ['X', 'Y', 'Z']


    ac_setList = {'X' : ac_setListX, 'Y' : ac_setListY, 'Z' : ac_setListZ}
    ac_grps = DictToTuple(ac_setList['X']) + DictToTuple(ac_setList['Y']) + DictToTuple(ac_setList['Z'])

    # real and imaginary coefficients of the source radiation terms (X1=dist, X2=k, X3=coef)
    coefDisR = FORMULE(NOM_PARA=('X1', 'X2', 'X3'),
                       VALE='X3*sin(X2*X1)/X1')

    coefDisI = FORMULE(NOM_PARA=('X1', 'X2', 'X3'),
                       VALE='-X3*cos(X2*X1)/X1')

    # pressure formulas; X4 will be equal to 1 if the macroelement instance is a simple translation
    # and to -1 if it constitutes the left part of the track and hence has undergone a 180° rotation
    # about Y. This means that the X and Z velocity components must be reversed.
    pressFR1 = FORMULE(NOM_PARA=('X1', 'X2', 'X3', 'DX', 'X4'),
                       VALE='X4*coefDisR(X1, X2, X3)*DX/1000.0',
                       coefDisR=coefDisR)

    pressFI1 = FORMULE(NOM_PARA=('X1', 'X2', 'X3', 'DX', 'X4'),
                       VALE='X4*coefDisI(X1, X2, X3)*DX/1000.0',
                       coefDisI=coefDisI)

    pressFR2 = FORMULE(NOM_PARA=('X1', 'X2', 'X3', 'DY', 'X4'),
                       VALE='coefDisR(X1, X2, X3)*DY/1000.0',
                       coefDisR=coefDisR)

    pressFI2 = FORMULE(NOM_PARA=('X1', 'X2', 'X3', 'DY', 'X4'),
                       VALE='coefDisI(X1, X2, X3)*DY/1000.0',
                       coefDisI=coefDisI)

    pressFR3 = FORMULE(NOM_PARA=('X1', 'X2', 'X3', 'DZ', 'X4'),
                       VALE='X4*coefDisR(X1, X2, X3)*DZ/1000.0',
                       coefDisR=coefDisR)

    pressFI3 = FORMULE(NOM_PARA=('X1', 'X2', 'X3', 'DZ', 'X4'),
                       VALE='X4*coefDisI(X1, X2, X3)*DZ/1000.0',
                       coefDisI=coefDisI)
                       
    # Pressure function fields macro 1
    if ac_setList['X'] != None:
        setListX = DictToTuple(ac_setList['X'])
        chFpr1 = CREA_CHAMP(AFFE=_F(GROUP_MA=setListX, NOM_CMP=('X5', 'X6'), VALE_F=(pressFR1, pressFI1)), MODELE=model, OPERATION='AFFE', TYPE_CHAM='NOEU_NEUT_F')

    if ac_setList['Y'] != None:
        setListY = DictToTuple(ac_setList['Y'])
        chFpr2 = CREA_CHAMP(AFFE=_F(GROUP_MA=setListY, NOM_CMP=('X5', 'X6'), VALE_F=(pressFR2, pressFI2)), MODELE=model, OPERATION='AFFE', TYPE_CHAM='NOEU_NEUT_F')

    if ac_setList['Z'] != None:
        setListZ = DictToTuple(ac_setList['Z'])
        chFpr3 = CREA_CHAMP(AFFE=_F(GROUP_MA=setListZ, NOM_CMP=('X5', 'X6'), VALE_F=(pressFR3, pressFI3)), MODELE=model, OPERATION='AFFE', TYPE_CHAM='NOEU_NEUT_F')

    # Pressure function fields macro 2
    if bool_macroEl2_Ph2:
        if ac_setList['X'] != None:
            chFpr12 = CREA_CHAMP(AFFE=_F(GROUP_MA=setListX, NOM_CMP=('X5', 'X6'), VALE_F=(pressFR1, pressFI1)), MODELE=model2, OPERATION='AFFE', TYPE_CHAM='NOEU_NEUT_F')
        if ac_setList['Y'] != None:
            chFpr22 = CREA_CHAMP(AFFE=_F(GROUP_MA=setListY, NOM_CMP=('X5', 'X6'), VALE_F=(pressFR2, pressFI2)), MODELE=model2, OPERATION='AFFE', TYPE_CHAM='NOEU_NEUT_F')
        if ac_setList['Z'] != None:
            chFpr32 = CREA_CHAMP(AFFE=_F(GROUP_MA=setListZ, NOM_CMP=('X5', 'X6'), VALE_F=(pressFR3, pressFI3)), MODELE=model2, OPERATION='AFFE', TYPE_CHAM='NOEU_NEUT_F')

<<<<<<< Updated upstream
######################################################
# BOUNDARY CONDITIONS AND INTERACTIONS
######################################################
if USP_on == True:
    BCs = (BCinterf, tie1, tie2, tie3, tie_clps)
else:
    BCs = (BCinterf, tie2, tie3, tie_clps)

dirNorm = (fDirVert**2 + fDirLat**2)**(1/2)
fNorm = 100000 # with a too low force value, displacements may be so low that we lose accuracy
fVert = fDirVert/dirNorm*fNorm
fLat = fDirLat/dirNorm*fNorm


load = AFFE_CHAR_MECA(FORCE_NODALE=_F(FX = 0,
                                      FY = -fVert,
                                      FZ = fLat,
                                      GROUP_NO=(nForce, )),
                      MODELE=model)


######################################################
# Import materials properties / functions
######################################################
f_EPad1=LIRE_FONCTION(UNITE = 30,
                     NOM_PARA = 'FREQ',
                     PROL_GAUCHE = 'LINEAIRE',
                     PROL_DROITE = 'LINEAIRE')
                 
f_TDPad1=LIRE_FONCTION(UNITE = 31,
                         NOM_PARA = 'FREQ',
                         PROL_GAUCHE = 'LINEAIRE',
                         PROL_DROITE = 'LINEAIRE')


f_EPad2=LIRE_FONCTION(UNITE = 32,
                     NOM_PARA = 'FREQ',
                     PROL_GAUCHE = 'LINEAIRE',
                     PROL_DROITE = 'LINEAIRE')
                 
f_TDPad2=LIRE_FONCTION(UNITE = 33,
                         NOM_PARA = 'FREQ',
                         PROL_GAUCHE = 'LINEAIRE',
                         PROL_DROITE = 'LINEAIRE')

if USP_on:
    f_EUSP=LIRE_FONCTION(UNITE = 34,
                         NOM_PARA = 'FREQ',
                         PROL_GAUCHE = 'LINEAIRE',
                         PROL_DROITE = 'LINEAIRE')
                     
    f_TDUSP=LIRE_FONCTION(UNITE = 35,
                             NOM_PARA = 'FREQ',
                             PROL_GAUCHE = 'LINEAIRE',
                             PROL_DROITE = 'LINEAIRE')
                         
f_EBal=LIRE_FONCTION(UNITE = 36,
                     NOM_PARA = 'FREQ',
                     PROL_GAUCHE = 'LINEAIRE',
                     PROL_DROITE = 'LINEAIRE')

f_TDBal=LIRE_FONCTION(UNITE = 37,
                         NOM_PARA = 'FREQ',
                         PROL_GAUCHE = 'LINEAIRE',
                         PROL_DROITE = 'LINEAIRE')

######################################################
# Get list of frequencies from freq files
######################################################
with open('fort.40') as freqFile:
    freqlines = freqFile.read().splitlines()
freqFile.close()

allFreqsJob = []
for freqline in freqlines:
    try:
        frequency=float(freqline.split(' ')[0])
    except:
        continue
    allFreqsJob.append(frequency)

######################################################
# Materials
######################################################
meanFreqJob = (allFreqsJob[0] + allFreqsJob[-1])/2

allFreqsJobNP = np.array(allFreqsJob)
AB_slprMat = GetAlphaBeta(allFreqsJobNP, tanDSleeper*np.ones(len(allFreqsJob)))
AB_railMat = GetAlphaBeta(allFreqsJobNP, tanDRail*np.ones(len(allFreqsJob)))

eta_padMat1 = np.array([f_TDPad1(f) for f in allFreqsJob])
AB_padMat1 = GetAlphaBeta(allFreqsJobNP, eta_padMat1)
eta_padMat2 = np.array([f_TDPad2(f) for f in allFreqsJob])
AB_padMat2 = GetAlphaBeta(allFreqsJobNP, eta_padMat2)

if USP_on:
    eta_USP = np.array([f_TDUSP(f) for f in allFreqsJob])
    AB_USP = GetAlphaBeta(allFreqsJobNP, eta_USP)
                    

# Before roration: XYZ=LTN ; after rotation (90° Y): XYZ=NTL="231". See R4.01.02
slprMat = DEFI_MATERIAU(ELAS_ORTH=_F(AMOR_ALPHA=AB_slprMat[0],
                                     AMOR_BETA=AB_slprMat[1],
                                     E_L=E1Sleeper,
                                     E_N=E3Sleeper,
                                     E_T=E2Sleeper,
                                     G_LN=E1Sleeper/2/(1+nuSleeper),
                                     G_LT=E1Sleeper/2/(1+nuSleeper),
                                     G_TN=E3Sleeper/2/(1+nuSleeper),
                                     NU_LN=nuSleeper,
                                     NU_LT=nuSleeper,
                                     NU_TN=nuSleeper,
                                     RHO=rhoSleeper*1e-12))
                            
railMat = DEFI_MATERIAU(ELAS=_F(AMOR_ALPHA=AB_railMat[0],
                              AMOR_BETA=AB_railMat[1],
                              E=ERail,
                              NU=nuRail,
                              RHO=rhoRail*1e-12))

padMat1 = DEFI_MATERIAU(ELAS=_F(AMOR_ALPHA=AB_padMat1[0],
                                AMOR_BETA=AB_padMat1[1],
                                E=f_EPad1(meanFreqJob)/scaling_slpX, # scaling_slpX
                                NU=nuPadMat1,
                                RHO=1.0e-09))
                                
padMat2 = DEFI_MATERIAU(ELAS=_F(AMOR_ALPHA=AB_padMat2[0],
                                AMOR_BETA=AB_padMat2[1],
                                E=f_EPad2(meanFreqJob)/scaling_slpX, # scaling_slpX
                                NU=nuPadMat2,
                                RHO=1.0e-09))   
    

if USP_on == True:
    USPmat = DEFI_MATERIAU(ELAS=_F(AMOR_ALPHA=AB_USP[0],
                                   AMOR_BETA=AB_USP[1],
                                   E=f_EUSP(meanFreqJob)/scaling_slpX,  # scaling_slpX
                                   NU=nuUSP,
                                   RHO=0.375e-09)) 
                               
    fieldmat = AFFE_MATERIAU(AFFE=(_F(GROUP_MA=('sleepere'),
                                      MATER=(slprMat, )),
                                   _F(GROUP_MA=('hard'),
                                      MATER=(padMat1, )),
                                   _F(GROUP_MA=('soft'),
                                      MATER=(padMat2, )),
                                   _F(GROUP_MA=('USPe'),
                                      MATER=(USPmat, )),
                                   _F(GROUP_MA=('raile'),
                                      MATER=(railMat, ))),
                             MAILLAGE=mesh,
                             MODELE=model,)
else:
    fieldmat = AFFE_MATERIAU(AFFE=(_F(GROUP_MA=('sleepere'),
                                      MATER=(slprMat, )),
                                   _F(GROUP_MA=('hard'),
                                      MATER=(padMat1, )),
                                   _F(GROUP_MA=('soft'),
                                      MATER=(padMat2, )),
                                   _F(GROUP_MA=('raile'),
                                      MATER=(railMat, ))),
                             MAILLAGE=mesh,
                             MODELE=model,)
                    
######################################################
# Affect caracteristics to elements
######################################################

# Get number of nodes in discreteBalNodes
pyMesh = partition.MAIL_PY()
pyMesh.FromAster('mesh')
nodeGrps = mesh.LIST_GROUP_NO()
for gp in nodeGrps:
    gpName = gp[0]
    if gpName == discreteBalNodes:
        gpNodes = pyMesh.gno.get(gpName)
        nNodesBal = len(gpNodes)
        break

# Compute area of a half-sleeper bottom face
CH_id = CREA_CHAMP(OPERATION = 'AFFE',
                      TYPE_CHAM ='NOEU_NEUT_R',
                      MAILLAGE = mesh ,
                      AFFE = _F(GROUP_MA='sftb', NOM_CMP=('X1'), VALE=1.0,))

intCH_id = POST_ELEM(CHAM_GD=CH_id,
                     INTEGRALE=_F(GROUP_MA='sftb',
                                  NOM_CMP=('X1'),
                                  TYPE_MAILLE='2D'),
                     MODELE=model)
                     
A_slpBot = intCH_id['INTE_X1',1]

nodeStiff_Y = f_EBal(meanFreqJob)*(coefSlpBotArea*A_slpBot)/(1000*hBal)/nNodesBal
nodeStiff_XZ = f_EBal(meanFreqJob)/2/(1+nuBal)*(coefSlpBotArea*A_slpBot)/(1000*hBal)/nNodesBal
nodeAmo_Y = nodeStiff_Y*f_TDBal(meanFreqJob)/(2*pi*meanFreqJob)
nodeAmo_XZ = nodeStiff_XZ*f_TDBal(meanFreqJob)/(2*pi*meanFreqJob)


elemprop = AFFE_CARA_ELEM(DISCRET=(_F(CARA='K_T_D_N',
                                      GROUP_MA=(discreteBalNodes+'0D'),
                                      REPERE='GLOBAL',
                                      VALE=(nodeStiff_XZ, nodeStiff_Y, nodeStiff_XZ),),
                                   _F(CARA='M_T_D_N',
                                      GROUP_MA=(discreteBalNodes+'0D'),
                                      REPERE='GLOBAL',
                                      VALE=0),
                                   _F(CARA='A_T_D_N',
                                      GROUP_MA=(discreteBalNodes+'0D'),
                                      REPERE='GLOBAL',
                                      VALE=(nodeAmo_XZ, nodeAmo_Y, nodeAmo_XZ)),
                                      
                                   _F(CARA='K_T_D_L',
                                      GROUP_MA=('clmp_ia', 'clmp_ib', 'clmp_ea', 'clmp_eb'),
                                      VALE=(clampStiffX,clampStiffY,clampStiffZ)
                                     ),
                                   _F(CARA='A_T_D_L',
                                      GROUP_MA=('clmp_ia', 'clmp_ib', 'clmp_ea', 'clmp_eb'),
                                      VALE=(clampDampX,clampDampY,clampDampZ)
                                     ),
                                      ),
                          # Before roration: XYZ=LTN ; after rotation (90° Y): XYZ=NTL.
                          MASSIF=_F(ANGL_REP=(0.0, 90.0, 0.0), GROUP_MA=('sleepere', )),
                          MODELE=model)

######################################################
# Select eigenmodes with largest effective unit mass
######################################################
listEigenModes = GetEigenModesList('fort.7', cumulX_mini, cumulY_mini, cumulZ_mini)

mod_trim = EXTR_MODE(FILTRE_MODE = _F(MODE=modes_1, NUME_MODE=listEigenModes))

######################################################
# Compute elementary matrices & assemble
######################################################
matEl_K1=CALC_MATR_ELEM(MODELE=model,
                        CHAM_MATER=fieldmat,
                        OPTION='RIGI_MECA',
                        CHARGE=BCs,
                        CARA_ELEM=elemprop)
                        
num2 = NUME_DDL(MATR_RIGI=matEl_K1)

matAs_K1 = ASSE_MATRICE(MATR_ELEM=matEl_K1, NUME_DDL=num2)

matEl_M1=CALC_MATR_ELEM(MODELE=model,
                        CHAM_MATER=fieldmat,
                        OPTION='MASS_MECA',
                        CHARGE=BCs,
                        CARA_ELEM=elemprop)
                        
matAs_M1 = ASSE_MATRICE(MATR_ELEM=matEl_M1, NUME_DDL=num2)

vectEl=CALC_VECT_ELEM(OPTION='CHAR_MECA',
                      CHARGE=load,
                      CARA_ELEM=elemprop)

vectAs = ASSE_VECTEUR(VECT_ELEM=vectEl, NUME_DDL=num2)

matEl_A1=CALC_MATR_ELEM(MODELE=model,
                        RIGI_MECA=matEl_K1,
                        MASS_MECA=matEl_M1,
                        CHAM_MATER=fieldmat,
                        OPTION='AMOR_MECA',
                        CHARGE=BCs,
                        CARA_ELEM=elemprop)
                        
matAs_A1 = ASSE_MATRICE(MATR_ELEM=matEl_A1, NUME_DDL=num2)  

######################################################
# Compute eigen modes (once since damping-independent)
######################################################
bamoRef = DEFI_BASE_MODALE(RITZ = _F(MODE_MECA=mod_trim))#, NUME_REF=num1)

nddlgen = NUME_DDL_GENE(BASE=bamoRef, STOCKAGE= 'PLEIN',);

matKgene = PROJ_MATR_BASE(BASE = bamoRef,
                          NUME_DDL_GENE = nddlgen,
                          MATR_ASSE = matAs_K1)

matMgene = PROJ_MATR_BASE(BASE = bamoRef,
                          NUME_DDL_GENE = nddlgen,
                          MATR_ASSE = matAs_M1)
               
modGene=CALC_MODES(TYPE_RESU='DYNAMIQUE',
                   MATR_RIGI=matKgene,
                   MATR_MASS=matMgene,
                   OPTION='TOUT',
                   SOLVEUR_MODAL=_F(METHODE='QZ'),
                   VERI_MODE=_F(STOP_ERREUR='NON',))


modes_2 = REST_GENE_PHYS(RESU_GENE=modGene, NUME_DDL=num2)

######################################################
# Compute static interface modes
######################################################
modStaR1=MODE_STATIQUE(MATR_RIGI=matAs_K1,
                       MATR_MASS=matAs_M1,
                       MODE_INTERF=_F(GROUP_NO = 'railBk',
                                      TOUT_CMP='OUI',
                                      NB_MODE=nModesRai,
                                      SHIFT=10,),);

modStaR2=MODE_STATIQUE(MATR_RIGI=matAs_K1,
                       MATR_MASS=matAs_M1,
                       MODE_INTERF=_F(GROUP_NO = 'railFt',
                                      TOUT_CMP='OUI',
                                      NB_MODE=nModesRai,
                                      SHIFT=10,),);

modStaS=MODE_STATIQUE(MATR_RIGI=matAs_K1,
                       MATR_MASS=matAs_M1,
                       MODE_INTERF=_F(GROUP_NO = 'slpSym',
                                      TOUT_CMP='OUI',
                                      NB_MODE=nModesSlp,
                                      SHIFT=100,),);

# Normalize static modes
modStaR1 = NORM_MODE(reuse=modStaR1, MODE=modStaR1, NORME='TRAN')
modStaR2 = NORM_MODE(reuse=modStaR2, MODE=modStaR2, NORME='TRAN')
modStaS = NORM_MODE(reuse=modStaS, MODE=modStaS, NORME='TRAN', INFO=2)

# Define dynamic interfaces   
Lint=DEFI_INTERF_DYNA(NUME_DDL=num1,
                      INTERFACE=(
                                 _F(NOM = 'I_slpSym',
                                    TYPE = 'CRAIGB',
                                    GROUP_NO = 'slpSym'),
                                 _F(NOM = 'I_raiRBk',
                                    TYPE = 'CRAIGB',
                                    GROUP_NO = 'railBk'),
                                 _F(NOM = 'I_raiRFt',
                                    TYPE = 'CRAIGB',
                                    GROUP_NO = 'railFt'),
                                    ))

######################################################
# Create modal basis
######################################################      
bamo1=DEFI_BASE_MODALE(RITZ=(_F(MODE_MECA = modes_2, ),
                             _F(MODE_INTF = modStaR1, ),
                             
                             ),
                       INTERF_DYNA=Lint,
                       NUME_REF=num2)

bamo1=DEFI_BASE_MODALE(reuse=bamo1,
                       RITZ=(_F(BASE_MODALE=bamo1),
                             _F(MODE_INTF = modStaR2, )),
                       NUME_REF=num2)

bamo1=DEFI_BASE_MODALE(reuse=bamo1,
                       RITZ=(_F(BASE_MODALE=bamo1),
                             _F(MODE_INTF = modStaS, )),
                       NUME_REF=num2)

# Add compression static mode
# mstat = MODE_STATIQUE (MATR_RIGI = matAs_K1, 
                       # FORCE_NODALE =_F(GROUP_NO = 'nAbvSlp', AVEC_CMP =('DY'),),)

# bamo1=DEFI_BASE_MODALE(reuse=bamo1,
                       # RITZ=(_F(BASE_MODALE=bamo1),
                             # _F(MODE_INTF = mstat, )),
                       # NUME_REF=num2)


    
######################################################
# Create macro element
######################################################
macroEl1 = MACR_ELEM_DYNA(BASE_MODALE=bamo1,
                          MATR_MASS=matAs_M1,
                          MATR_RIGI=matAs_K1,
                          MATR_AMOR=matAs_A1)
                          

######################################################
# Macroelements coupling and generalized model creation
######################################################
substructs = []
liaisons = []
for i in range(nSlp):
    substR = _F(NOM = 'elem'+str(i)+'R', MACR_ELEM_DYNA = macroEl1, ANGL_NAUT = (0., 0., 0.), TRANS=(i*slpSpacing,0.,0.))
    substL = _F(NOM = 'elem'+str(i)+'L', MACR_ELEM_DYNA = macroEl1, ANGL_NAUT = (0., 180., 0.), TRANS=(i*slpSpacing,0.,0.))
    substructs.append(substR)
    substructs.append(substL)
    
    liais2 = _F(SOUS_STRUC_1 = 'elem'+str(i)+'R', SOUS_STRUC_2 = 'elem'+str(i)+'L', INTERFACE_1  = 'I_slpSym', INTERFACE_2  = 'I_slpSym', OPTION='REDUIT')
    liaisons.append(liais2)
    
    if i != nSlp-1:
        liais4 = _F(SOUS_STRUC_1 = 'elem'+str(i)+'R', SOUS_STRUC_2 = 'elem'+str(i+1)+'R', INTERFACE_1  = 'I_raiRFt', INTERFACE_2  = 'I_raiRBk', OPTION='REDUIT')
        liais6 = _F(SOUS_STRUC_1 = 'elem'+str(i)+'L', SOUS_STRUC_2 = 'elem'+str(i+1)+'L', INTERFACE_1  = 'I_raiRBk', INTERFACE_2  = 'I_raiRFt', OPTION='REDUIT')
        liaisons.append(liais4)
        liaisons.append(liais6)

modeGene=DEFI_MODELE_GENE(SOUS_STRUC=substructs, LIAISON=liaisons, VERIF=_F( STOP_ERREUR = 'OUI', PRECISION = 1.E-6, CRITERE = 'RELATIF'))
numGene=NUME_DDL_GENE(MODELE_GENE=modeGene);

######################################################
# ASSEMBLAGE DES MATRICES RAIDEUR ET MASSE GENERALISEES STATIQUES
######################################################
masGene=ASSE_MATR_GENE(NUME_DDL_GENE=numGene, OPTION='MASS_GENE');

rigGene=ASSE_MATR_GENE(NUME_DDL_GENE=numGene, OPTION='RIGI_GENE');
                                  
amoGene=ASSE_MATR_GENE(NUME_DDL_GENE=numGene, OPTION='AMOR_GENE');

vectGene=ASSE_VECT_GENE(NUME_DDL_GENE=numGene,CHAR_SOUS_STRUC=(_F(SOUS_STRUC = 'elem'+str(slpForce-1)+'R',VECT_ASSE = vectAs),))        
                
######################################################
# HARMONIC SIMULATION
######################################################
# harmGene = DYNA_VIBRA(BASE_CALCUL='GENE',
                      # TYPE_CALCUL='HARM',
                      # MATR_MASS=masGene,
                      # MATR_RIGI=rigGene,
                      # MATR_AMOR=amoGene,
                      # FREQ=allFreqsJob,
                      # TOUT_CHAM='OUI', #NOM_CHAM=('DEPL', 'VITE', 'ACCE'),
                      # EXCIT=_F(VECT_ASSE_GENE=vectGene, COEF_MULT=1.0,),
                      # SOLVEUR=_F(METHODE='LDLT',
                                 # RENUM='RCMK',
                                 # NPREC=8,
                                 # ELIM_LAGR='NON',
                                 # STOP_SINGULIER='OUI',),)

harmGene = DYNA_VIBRA(BASE_CALCUL='GENE',
                      TYPE_CALCUL='HARM',
                      MATR_MASS=masGene,
                      MATR_RIGI=rigGene,
                      MATR_AMOR=amoGene,
                      FREQ=allFreqsJob,
                      TOUT_CHAM='OUI', #NOM_CHAM=('DEPL', 'VITE', 'ACCE'),
                      EXCIT=_F(VECT_ASSE_GENE=vectGene, COEF_MULT=1.0,),
                      SOLVEUR=_F(METHODE='MUMPS', ELIM_LAGR='NON',),)
=======
    # Pressure function fields macro 2S
    if bool_macroEl2_slpShift:
        if ac_setList['X'] != None:
            chFpr12S = CREA_CHAMP(AFFE=_F(GROUP_MA=setListX, NOM_CMP=('X5', 'X6'), VALE_F=(pressFR1, pressFI1)), MODELE=model2S, OPERATION='AFFE', TYPE_CHAM='NOEU_NEUT_F')
        if ac_setList['Y'] != None:
            chFpr22S = CREA_CHAMP(AFFE=_F(GROUP_MA=setListY, NOM_CMP=('X5', 'X6'), VALE_F=(pressFR2, pressFI2)), MODELE=model2S, OPERATION='AFFE', TYPE_CHAM='NOEU_NEUT_F')
        if ac_setList['Z'] != None:
            chFpr32S = CREA_CHAMP(AFFE=_F(GROUP_MA=setListZ, NOM_CMP=('X5', 'X6'), VALE_F=(pressFR3, pressFI3)), MODELE=model2S, OPERATION='AFFE', TYPE_CHAM='NOEU_NEUT_F')
>>>>>>> Stashed changes

######################################################
# COMPUTE ACOUSTIC PART
######################################################
nSlpAcoustRange = range(nSlpAcoust1-1, nSlpAcoust2)

if computeAcoustic == True:

    # Initialize acoustic results txt files
    if acMeshDim == '2D':
        # Initialize acoustic power file
        fileHeader='Acoustic power [W/N2]\nFreq [Hz]\tTotal\tRails\tSleepers\n'
        filePow=open('fort.41','w')
        filePow.write(fileHeader)
        filePow.close()
    elif acMeshDim == '1D':                          
        # Initialize acoustic pressure file
        fileHeader='f\t'
        for node in acousticNodes:
            grpName = node['name']
            fileHeader +=  grpName + '_pTot [Pa/N]\t' + grpName + '_pRai [Pa/N]\t' + grpName + '_pSlp [Pa/N]\t'
            i += 1

        fileHeader += '\n'
        filePress=open('fort.41','w')
        filePress.write(fileHeader)
        filePress.close()

    # Fields *1 and *(-1), macroelement 1
    CH1 = CREA_CHAMP(OPERATION='AFFE',TYPE_CHAM='NOEU_NEUT_R', MODELE=model, AFFE=_F(TOUT='OUI', NOM_CMP=('X4'),VALE=1))
    CHm1 = CREA_CHAMP(OPERATION='AFFE',TYPE_CHAM='NOEU_NEUT_R', MODELE=model, AFFE=_F(TOUT='OUI', NOM_CMP=('X4'),VALE=-1))

    # Fields *1 and *(-1), macroelement 2
    if bool_macroEl2_Ph2:
        CH1_2 = CREA_CHAMP(OPERATION='AFFE',TYPE_CHAM='NOEU_NEUT_R', MODELE=model2, AFFE=_F(TOUT='OUI', NOM_CMP=('X4'),VALE=1))
        CHm1_2 = CREA_CHAMP(OPERATION='AFFE',TYPE_CHAM='NOEU_NEUT_R', MODELE=model2, AFFE=_F(TOUT='OUI', NOM_CMP=('X4'),VALE=-1))

    # Fields *1 and *(-1), macroelement 2S
    if bool_macroEl2_slpShift:
        CH1_2S = CREA_CHAMP(OPERATION='AFFE',TYPE_CHAM='NOEU_NEUT_R', MODELE=model2S, AFFE=_F(TOUT='OUI', NOM_CMP=('X4'),VALE=1))
        CHm1_2S = CREA_CHAMP(OPERATION='AFFE',TYPE_CHAM='NOEU_NEUT_R', MODELE=model2S, AFFE=_F(TOUT='OUI', NOM_CMP=('X4'),VALE=-1))

    for freq in allFreqsJob:
        omega = 2 * math.pi * freq
        k = omega / c
        coef = rho * c * k / 2.0 / math.pi

        #Define constant fields macroelement 1
        CHk = CREA_CHAMP(OPERATION='AFFE',TYPE_CHAM='NOEU_NEUT_R', MODELE=model, AFFE=_F(TOUT='OUI', NOM_CMP=('X2'),VALE=k))
        CHcoef = CREA_CHAMP(OPERATION='AFFE',TYPE_CHAM='NOEU_NEUT_R', MODELE=model, AFFE=_F(TOUT='OUI', NOM_CMP=('X3'),VALE=coef))

        #Define constant fields macroelement 2
        if bool_macroEl2_Ph2:
            CHk2 = CREA_CHAMP(OPERATION='AFFE',TYPE_CHAM='NOEU_NEUT_R', MODELE=model2, AFFE=_F(TOUT='OUI', NOM_CMP=('X2'),VALE=k))
            CHcoef2 = CREA_CHAMP(OPERATION='AFFE',TYPE_CHAM='NOEU_NEUT_R', MODELE=model2, AFFE=_F(TOUT='OUI', NOM_CMP=('X3'),VALE=coef))

        #Define constant fields macroelement 2S
        if bool_macroEl2_slpShift:
            CHk2S = CREA_CHAMP(OPERATION='AFFE',TYPE_CHAM='NOEU_NEUT_R', MODELE=model2S, AFFE=_F(TOUT='OUI', NOM_CMP=('X2'),VALE=k))
            CHcoef2S = CREA_CHAMP(OPERATION='AFFE',TYPE_CHAM='NOEU_NEUT_R', MODELE=model2S, AFFE=_F(TOUT='OUI', NOM_CMP=('X3'),VALE=coef))

        # All velocity fields extracted once per frequency. Then they will be reused but not recomputed afterwards
        velR = [None]*nSlp*2
        velI = [None]*nSlp*2
        ii = 0

        for iElem in nSlpAcoustRange: 
            for side in ['R', 'L']:
                resPhy = REST_SOUS_STRUC(RESU_GENE=harmGene, TOUT_CHAM='OUI', SOUS_STRUC='elem'+str(iElem)+side)

                velocity = CREA_CHAMP(FREQ=freq, NOM_CHAM='VITE', OPERATION='EXTR', RESULTAT=resPhy, TYPE_CHAM='NOEU_DEPL_C')

                if not bool_macroEl2_Ph2 or parameters["macroElSequence"][iElem] == 1:
                    vel_Grps = CREA_CHAMP(MODELE=model, TYPE_CHAM='NOEU_DEPL_C', OPERATION='ASSE', ASSE=_F(GROUP_MA=ac_grps, CHAM_GD=velocity))
                else:
                    if parameters["macroElSequence"][iElem] == 2:
                        if bool_macroEl2_slpShift:
                            if side == 'R':
                                vel_Grps = CREA_CHAMP(MODELE=model2, TYPE_CHAM='NOEU_DEPL_C', OPERATION='ASSE', ASSE=_F(GROUP_MA=ac_grps, CHAM_GD=velocity))
                            elif side == 'L':
                                vel_Grps = CREA_CHAMP(MODELE=model2S, TYPE_CHAM='NOEU_DEPL_C', OPERATION='ASSE', ASSE=_F(GROUP_MA=ac_grps, CHAM_GD=velocity))
                        else:
                            vel_Grps = CREA_CHAMP(MODELE=model2, TYPE_CHAM='NOEU_DEPL_C', OPERATION='ASSE', ASSE=_F(GROUP_MA=ac_grps, CHAM_GD=velocity))
                    elif parameters["macroElSequence"][iElem] == 3:
                        if side == 'R':
                            vel_Grps = CREA_CHAMP(MODELE=model2S, TYPE_CHAM='NOEU_DEPL_C', OPERATION='ASSE', ASSE=_F(GROUP_MA=ac_grps, CHAM_GD=velocity))
                        elif side == 'L':
                            vel_Grps = CREA_CHAMP(MODELE=model2, TYPE_CHAM='NOEU_DEPL_C', OPERATION='ASSE', ASSE=_F(GROUP_MA=ac_grps, CHAM_GD=velocity))

                # velR and velI are 2*nSlp-long lists               
                velR[ii] = CREA_CHAMP(CHAM_GD=vel_Grps, OPERATION='C2R', PARTIE='REEL', TYPE_CHAM='NOEU_DEPL_R')
                velI[ii] = CREA_CHAMP(CHAM_GD=vel_Grps, OPERATION='C2R', PARTIE='IMAG', TYPE_CHAM='NOEU_DEPL_R')

                DETRUIRE(CONCEPT=_F(NOM=(resPhy, velocity, vel_Grps)))
                ii += 1

        # Iterate over grid nodes (mesh groups)
        listeAffe = []
        listeAffeI = []
        pressDataLine = [str(freq)]

        for i in range(len(acousticNodes)):
            nodeDict = acousticNodes[i] 
    
            p_rails_R = 0
            p_rails_I = 0
            p_sleepers_R = 0
            p_sleepers_I = 0
            
            ii=0
            for iElem in nSlpAcoustRange: 
                for side in ['R', 'L']: # in this section we deal with 1 particular macroelement

                    # Iterate over directions
                    for dir in dirContribs:
                        
                        # Compute distance field
                        if not bool_macroEl2_Ph2 or parameters["macroElSequence"][iElem] == 1:
                            chDist = computeDistance(model, mesh, nodeDict['coords'], ac_setList[dir], iElem, side)
                        else:
                            if parameters["macroElSequence"][iElem] == 2:
                                if bool_macroEl2_slpShift:
                                    if side == 'R':
                                        chDist = computeDistance(model2, mesh2, nodeDict['coords'], ac_setList[dir], iElem, side)
                                    elif side == 'L':
                                        chDist = computeDistance(model2S, mesh2S, nodeDict['coords'], ac_setList[dir], iElem, side)
                                else:
                                    chDist = computeDistance(model2, mesh2, nodeDict['coords'], ac_setList[dir], iElem, side)
                            elif parameters["macroElSequence"][iElem] == 3:
                                if side == 'R':
                                    chDist = computeDistance(model2S, mesh2S, nodeDict['coords'], ac_setList[dir], iElem, side)
                                elif side == 'L':
                                    chDist = computeDistance(model2, mesh2, nodeDict['coords'], ac_setList[dir], iElem, side)

                        # acoustic computations (costliest commands): ComputePressure()~0.17s
                        if not bool_macroEl2_Ph2 or parameters["macroElSequence"][iElem] == 1:
                            if dir == 'X':
                                pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model, chFpr1, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk, CHcoef, CH1, CHm1)
                            elif dir == 'Y':
                                pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model, chFpr2, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk, CHcoef, CH1, CHm1)
                            elif dir == 'Z':
                                pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model, chFpr3, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk, CHcoef, CH1, CHm1)
                        else:
                            if parameters["macroElSequence"][iElem] == 2:
                                if bool_macroEl2_slpShift:
                                    if side == 'R':
                                        if dir == 'X':
                                            pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model2, chFpr12, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk2, CHcoef2, CH1_2, CHm1_2)
                                        if dir == 'Y':
                                            pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model2, chFpr22, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk2, CHcoef2, CH1_2, CHm1_2)
                                        if dir == 'Z':
                                            pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model2, chFpr32, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk2, CHcoef2, CH1_2, CHm1_2)
                                    elif side == 'L':
                                        if dir == 'X':
                                            pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model2S, chFpr12S, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk2S, CHcoef2S, CH1_2S, CHm1_2S)
                                        if dir == 'Y':
                                            pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model2S, chFpr22S, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk2S, CHcoef2S, CH1_2S, CHm1_2S)
                                        if dir == 'Z':
                                            pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model2S, chFpr32S, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk2S, CHcoef2S, CH1_2S, CHm1_2S)
                                else:
                                    if dir == 'X':
                                        pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model2, chFpr12, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk2, CHcoef2, CH1_2, CHm1_2)
                                    if dir == 'Y':
                                        pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model2, chFpr22, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk2, CHcoef2, CH1_2, CHm1_2)
                                    if dir == 'Z':
                                        pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model2, chFpr32, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk2, CHcoef2, CH1_2, CHm1_2)
                            elif parameters["macroElSequence"][iElem] == 3:
                                if side == 'R':
                                    if dir == 'X':
                                        pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model2S, chFpr12S, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk2S, CHcoef2S, CH1_2S, CHm1_2S)
                                    if dir == 'Y':
                                        pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model2S, chFpr22S, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk2S, CHcoef2S, CH1_2S, CHm1_2S)
                                    if dir == 'Z':
                                        pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model2S, chFpr32S, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk2S, CHcoef2S, CH1_2S, CHm1_2S)
                                elif side == 'L':
                                    if dir == 'X':
                                        pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model2, chFpr12, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk2, CHcoef2, CH1_2, CHm1_2)
                                    if dir == 'Y':
                                        pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model2, chFpr22, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk2, CHcoef2, CH1_2, CHm1_2)
                                    if dir == 'Z':
                                        pI_rails_R, pI_rails_I, pI_sleepers_R, pI_sleepers_I = computePressure(model2, chFpr32, ac_setList[dir], velR[ii], velI[ii], side, chDist, CHk2, CHcoef2, CH1_2, CHm1_2)

                        p_rails_R += pI_rails_R
                        p_rails_I += pI_rails_I
                        p_sleepers_R += pI_sleepers_R
                        p_sleepers_I += pI_sleepers_I

                        DETRUIRE(CONCEPT=_F(NOM=(chDist,)))
                        
                    ii += 1

            p_tot_R = p_rails_R + p_sleepers_R
            p_tot_I = p_rails_I + p_sleepers_I
            
            nodeDict['freqs'].append(frequency)
            nodeDict['p_tot_R'].append(p_tot_R)
            nodeDict['p_tot_I'].append(p_tot_I)
            nodeDict['p_rails_R'].append(p_rails_R)
            nodeDict['p_rails_I'].append(p_rails_I)
            nodeDict['p_sleepers_R'].append(p_sleepers_R)
            nodeDict['p_sleepers_I'].append(p_sleepers_I)

            if writeMED:
                listeAffe.append(_F(GROUP_NO=nodeDict['name'], NOM_CMP=('SIXX', 'SIYY', 'SIZZ', 'SIXY', 'SIXZ', 'SIYZ'), VALE=(p_tot_R, p_tot_I, p_rails_R, p_rails_I, p_sleepers_R, p_sleepers_I),))
            
            if acMeshDim == '2D':        
                I_tot = (p_tot_R**2 + p_tot_I**2)/(rho*c)
                I_rails = (p_rails_R**2 + p_rails_I**2)/(rho*c)
                I_sleepers = (p_sleepers_R**2 + p_sleepers_I**2)/(rho*c)
                listeAffeI.append(_F(GROUP_NO=nodeDict['name'], NOM_CMP=('X1', 'X2', 'X3'), VALE=(I_tot, I_rails, I_sleepers),))
            elif acMeshDim == '1D':
                pressDataLine += [str((p_tot_R**2+p_tot_I**2)**(1/2)/fNorm), str((p_rails_R**2+p_rails_I**2)**(1/2)/fNorm), str((p_sleepers_R**2+p_sleepers_I**2)**(1/2)/fNorm)]

        if acMeshDim == '2D':
            CH_Iac = CREA_CHAMP(OPERATION = 'AFFE',
                                TYPE_CHAM ='NOEU_NEUT_R',
                                MAILLAGE = grid ,
                                AFFE = (listeAffeI))

            intField = POST_ELEM(CHAM_GD=CH_Iac,
                                 INTEGRALE=_F(TOUT='OUI',
                                              NOM_CMP=('X1', 'X2', 'X3'),
                                              TYPE_MAILLE='2D'),
                                 MODELE=gridMod)
                  
            W_tot = intField['INTE_X1',1]/1e6/fNorm**2 # in W/N^2
            W_rails = intField['INTE_X2',1]/1e6/fNorm**2
            W_sleepers = intField['INTE_X3',1]/1e6/fNorm**2
       
            dataLine = [str(freq), str(W_tot), str(W_rails), str(W_sleepers)]
            fileContent = '\t'.join(dataLine) + '\n'    #dataLine=["abc", "def", ...]
            filePow=open('fort.41','a+')
            filePow.write(fileContent)
            filePow.close()
        elif acMeshDim == '1D':
            fileContent = '\t'.join(pressDataLine) + '\n'    #dataLine=["abc", "def", ...]
            filePress=open('fort.41','a+')
            filePress.write(fileContent)
            filePress.close()   
        
        if writeMED:
            CH_pAc = CREA_CHAMP(OPERATION = 'AFFE',
                                TYPE_CHAM ='NOEU_SIEF_R',
                                MAILLAGE = grid ,
                                AFFE = (listeAffe))
        
        if writeMED:
            if freq == allFreqsJob[0]:
                RESpre=CREA_RESU(OPERATION='AFFE',TYPE_RESU='DYNA_HARMO',NOM_CHAM='SIEF_NOEU',AFFE=_F(CHAM_GD=CH_pAc, FREQ=freq),);
            else:
                RESpre=CREA_RESU(reuse=RESpre, RESULTAT=RESpre, OPERATION='AFFE',TYPE_RESU='DYNA_HARMO',NOM_CHAM='SIEF_NOEU',AFFE=_F(CHAM_GD=CH_pAc, FREQ=freq),);

        for j in range(len(velR)):
            try:
                DETRUIRE(CONCEPT=_F(NOM=(velR[j], velI[j])))
            except:
                pass
            if acMeshDim == '2D':
                try:
                    DETRUIRE(CONCEPT=_F(NOM=(CH_Iac, intField)))
                except:
                    pass

        if writeMED:
            DETRUIRE(CONCEPT=_F(NOM=(CH_pAc)))

        DETRUIRE(CONCEPT=_F(NOM=(CHk, CHcoef, )))
        if bool_macroEl2_Ph2:
            DETRUIRE(CONCEPT=_F(NOM=(CHk2, CHcoef2, )))
        if bool_macroEl2_slpShift:
            DETRUIRE(CONCEPT=_F(NOM=(CHk2S, CHcoef2S, )))
        
    if writeMED:
        IMPR_RESU(FORMAT='MED',
                RESU=_F(PARTIE='REEL',
                        NOM_CHAM='SIEF_NOEU',
                        NOM_CHAM_MED = 'acPressure',
                        RESULTAT=RESpre,),
                UNITE=81)
                            
                  
######################################################
# RECONSTRUCT PHYSICAL MODEL
######################################################
if writeMED:
    substructs2 = []
    # for i in range(nSlp):
    for i in nSlpAcoustRange:
        substructs2.append(_F(NOM='elem'+str(i)+'R', GROUP_MA='TOUT'))
        substructs2.append(_F(NOM='elem'+str(i)+'L', GROUP_MA='TOUT'))
                                
    squel=DEFI_SQUELETTE(MODELE_GENE=modeGene,
                        SOUS_STRUC=substructs2)

    harmGlob=REST_SOUS_STRUC(RESU_GENE=harmGene, 
                            SQUELETTE=squel,
                            NOM_CHAM='DEPL',)

    for freq in allFreqsJob:
        out = CREA_CHAMP(FREQ=freq,
                            NOM_CHAM='DEPL',
                            OPERATION='EXTR',
                            RESULTAT=harmGlob,
                            TYPE_CHAM='NOEU_DEPL_C')
                            
        outMag = CREA_CHAMP(CHAM_GD=out,
                            OPERATION='C2R',
                            PARTIE='REEL',
                            TYPE_CHAM='NOEU_DEPL_R')

        # outPhas = CREA_CHAMP(CHAM_GD=out,
                            # OPERATION='C2R',
                            # PARTIE='PHASE',
                            # TYPE_CHAM='NOEU_DEPL_R')
            
        if freq == allFreqsJob[0]:
            resOut = CREA_RESU(OPERATION='AFFE',TYPE_RESU='DYNA_HARMO',NOM_CHAM='DEPL',AFFE=_F(CHAM_GD=outMag, FREQ=freq),);
            # resOut2 = CREA_RESU(OPERATION='AFFE',TYPE_RESU='DYNA_HARMO',NOM_CHAM=FRFtype,AFFE=_F(CHAM_GD=outPhas, FREQ=freq),);
        else:
            resOut = CREA_RESU(reuse=resOut, RESULTAT=resOut, OPERATION='AFFE',TYPE_RESU='DYNA_HARMO',NOM_CHAM='DEPL',AFFE=_F(CHAM_GD=outMag, FREQ=freq),);
            # resOut2 = CREA_RESU(reuse=resOut2, RESULTAT=resOut2, OPERATION='AFFE',TYPE_RESU='DYNA_HARMO',NOM_CHAM=FRFtype,AFFE=_F(CHAM_GD=outPhas, FREQ=freq),);
            
        DETRUIRE(CONCEPT=_F(NOM=(out, outMag, )))# outPhas)))

    IMPR_RESU(FORMAT='MED',
            RESU=_F(RESULTAT=resOut,
                    PARTIE='REEL',
                    NOM_CHAM='DEPL',
                    NOM_CHAM_MED = 'resOut',),
            UNITE=80)

    # IMPR_RESU(FORMAT='MED',
            # RESU=_F(RESULTAT=resOut2,
                    # PARTIE='REEL',
                    # TOUT_CHAM='OUI'),
            # UNITE=85)

    IMPR_RESU(FORMAT='MED',
            RESU=_F(MAILLAGE=squel,),
            UNITE=28)

######################################################
# POST-PROCESSING : Get force-velocity FRF functions
######################################################
FRFs = [None]*len(selectedSubstFRF)*len(nodesFRF)
phase = [None]*len(selectedSubstFRF)*len(nodesFRF)

if FRFtype == 'VITE':
    units = '[m/(s.N)]'
    normCoef = 1/1000/fNorm
elif FRFtype == 'ACCE':
    units = '[g/N]'
    normCoef = 1/1000/9.81/fNorm
elif FRFtype == 'DEPL':
    units = '[mm/N]'
    normCoef = 1/fNorm
else:
    units = '[?]'
    normCoef = 1

fileFRFContent = 'f [Hz]'
for substr in selectedSubstFRF:   
    for grp in nodesFRF:
        fileFRFContent += '\tE' + str(substr) + '_' + grp + ' ' + units
        fileFRFContent += '\tE' + str(substr) + '_' + grp + '_phase [°]'
fileFRFContent += '\n'

# pyGrid.FromAster('mesh')
j = 0
for substr in selectedSubstFRF:  

    try:
        DETRUIRE(CONCEPT=_F(NOM=(struR)))
    except:
        pass

    struR = REST_SOUS_STRUC(RESU_GENE=harmGene,
                            NOM_CHAM=FRFtype,
                            SOUS_STRUC= 'elem' + str(substr - 1) + 'R' )

    for grp in nodesFRF: # grp = 'Ra_Y' for example
        gpNode = pyMesh.gno.get(grp)
        
        # just a test to make sure the group exists
        try:
            for node in gpNode:
                break 
        except:
            print('GROUP OF NODE ' + grp + ' NOT FOUND !')
            j += 1
            continue
        
        valuesMag = [] # contains an FRF for each node of the group of node
        valuesPh = []

        # for each node of gpNode, get the FRF mag and phase, and append it to valuesMag & valuesPh
        for node in gpNode: # node = 18673 for example
            valuesMag.append([])
            valuesPh.append([])
            nodeName = 'N' + str(node)
            fY = RECU_FONCTION(NOEUD=nodeName, NOM_CHAM=FRFtype, NOM_CMP='DY', RESULTAT=struR,)
            fZ = RECU_FONCTION(NOEUD=nodeName, NOM_CHAM=FRFtype, NOM_CMP='DZ', RESULTAT=struR,)
            fMagnY = CALC_FONCTION(EXTRACTION=_F(FONCTION=fY, PARTIE='MODULE'))
            fMagnZ = CALC_FONCTION(EXTRACTION=_F(FONCTION=fZ, PARTIE='MODULE'))
            fPhase = CALC_FONCTION(EXTRACTION=_F(FONCTION=fY, PARTIE='PHASE'))
            for freq in allFreqsJob:
                if grp[-1] == 'Y':
                    valuesMag[-1].append(fMagnY(freq))
                elif grp[-1] == 'Z':
                    valuesMag[-1].append(fMagnZ(freq))
                else:
                    fMagn = (fMagnY(freq)**2 + fMagnZ(freq)**2)**(1/2.0)
                    valuesMag[-1].append(fMagn)
                valuesPh[-1].append(fPhase(freq))
                
            DETRUIRE(CONCEPT=_F(NOM=(fY, fZ, fMagnY, fMagnZ, fPhase)))
        
        # For group grp, average the FRFs from all nodes
        meanFRF = np.array([0.0]*len(allFreqsJob))
        for vect in valuesMag:  # vect is the FRF of one node of the group of node
            for k in range(len(vect)):
                meanFRF[k] += vect[k]
        meanFRF /= len(valuesMag)

        # Same for phases
        mnFRF_ph = np.array([0.0]*len(allFreqsJob))
        for vect in valuesPh:  # vect is the FRF phase of one node of the group of node
            for k in range(len(vect)):
                mnFRF_ph[k] += vect[k]
        mnFRF_ph /= len(valuesPh)

        # FRF function on a group on a macroelement
        FRFs[j] = DEFI_FONCTION(NOM_PARA = 'FREQ', 
                               ABSCISSE = allFreqsJob + [allFreqsJob[-1]+1e-2]*int(len(allFreqsJob)==1),
                               ORDONNEE = np.append(meanFRF, [meanFRF[-1]]*int(len(allFreqsJob)==1)))
        
        phase[j] = DEFI_FONCTION(NOM_PARA = 'FREQ', 
                               ABSCISSE = allFreqsJob + [allFreqsJob[-1]+1e-2]*int(len(allFreqsJob)==1),
                               ORDONNEE = np.append(mnFRF_ph, [mnFRF_ph[-1]]*int(len(allFreqsJob)==1)))
                               
        j += 1
      
for freq in allFreqsJob:
    FRFdataline = [str(freq)]
    
    for i, frf in enumerate(FRFs):
        if frf is None:
            FRFdataline.append('NaN')
        else:
            FRFdataline.append(str(frf(freq)*normCoef))

        phs = phase[i]
        if phs is None:
            FRFdataline.append('NaN')
        else:
            FRFdataline.append(str(phs(freq)))

    fileFRFContent += '\t'.join(FRFdataline) + '\n'

fileFRF=open('fort.83','w')
fileFRF.write(fileFRFContent)
fileFRF.close()


######################################################\
# Write result files (MED)
######################################################
if writeMED:
	IMPR_RESU(FORMAT='MED',
			RESU=_F(RESULTAT=bamo1,), # mod_trim
			UNITE=82)

FIN()
